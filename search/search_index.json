{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ProcTap","text":"<p>Cross-Platform Per-Process Audio Capture</p> <p> </p> <p>ProcTap is a cross-platform Python library that enables per-process audio capture with platform-optimized backends:</p> <ul> <li>Windows: WASAPI Process Loopback (C++ native extension)</li> <li>Linux: PipeWire Native / PulseAudio (fully supported)</li> <li>macOS: ScreenCaptureKit (officially supported, v0.4.0+)</li> </ul> <p>It lets you capture audio from a specific process only \u2014 without system sounds or other app audio mixed in.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfa7 Per-Process Audio Isolation - Capture from a single target process (games, browsers, DAWs, etc.)</li> <li>\ud83c\udf0d Cross-Platform - Windows 10/11+ | Linux (PipeWire/PulseAudio) | macOS 13+</li> <li>\u26a1 Platform-Optimized Backends - WASAPI (Windows), PipeWire/PulseAudio (Linux), ScreenCaptureKit (macOS)</li> <li>\ud83e\uddf5 Low-Latency Audio Engine - 10-15ms latency across all platforms</li> <li>\ud83d\udc0d Python-Friendly API - Callback-based and async iterator patterns</li> <li>\ud83d\udd0c Native Performance - C++ extension (Windows), native APIs (Linux/macOS)</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from proctap import ProcessAudioCapture\nimport wave\nimport numpy as np\n\n# Open WAV file for writing\nwav = wave.open(\"output.wav\", \"wb\")\nwav.setnchannels(2)\nwav.setsampwidth(2)  # 16-bit PCM\nwav.setframerate(48000)\n\n# Callback to convert float32 to int16 and write\ndef on_data(pcm, frames):\n    # Convert float32 to int16 for WAV\n    float_samples = np.frombuffer(pcm, dtype=np.float32)\n    int16_samples = (np.clip(float_samples, -1.0, 1.0) * 32767).astype(np.int16)\n    wav.writeframes(int16_samples.tobytes())\n\n# Start capturing from process ID 12345\nwith ProcessAudioCapture(pid=12345, on_data=on_data):\n    input(\"Recording... Press Enter to stop.\\n\")\n\nwav.close()\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install proc-tap\n</code></pre> <p>For development installation and building from source, see the Installation Guide.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>\ud83c\udfae Record audio from one game only</li> <li>\ud83d\udd76 Capture VRChat audio cleanly (without system sounds)</li> <li>\ud83c\udf99 Feed high-SNR audio into AI recognition models</li> <li>\ud83d\udcf9 Alternative to OBS \"Application Audio Capture\"</li> <li>\ud83c\udfa7 Capture DAW/app playback for analysis tools</li> </ul>"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#windows-fully-supported","title":"Windows (Fully Supported)","text":"<ul> <li>OS: Windows 10 / 11 (20H1 or later)</li> <li>Python: 3.10+</li> <li>WASAPI: Built into Windows</li> <li>Privileges: No administrator rights required</li> </ul>"},{"location":"#linux-fully-supported","title":"Linux (Fully Supported)","text":"<ul> <li>OS: Linux with PulseAudio or PipeWire</li> <li>Python: 3.10+</li> <li>System Packages: <code>pulseaudio-utils</code> or <code>pipewire</code></li> <li>Auto-detection: Graceful fallback between backends</li> </ul>"},{"location":"#macos-officially-supported-v040","title":"macOS (Officially Supported - v0.4.0+)","text":"<ul> <li>OS: macOS 13.0 (Ventura) or later</li> <li>Python: 3.10+</li> <li>Backend: ScreenCaptureKit (bundleID-based)</li> <li>Permissions: Screen Recording (automatically prompted)</li> <li>Requirements: Swift toolchain for building helper binary</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Install ProcTap</li> <li>Quick Start - Get started in 5 minutes</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>\ud83d\udc1b Report Bugs</li> <li>\u2728 Request Features</li> <li>\ud83d\udcac Discussions</li> <li>\ud83d\udcd6 GitHub Repository</li> </ul>"},{"location":"#license","title":"License","text":"<p>ProcTap is released under the MIT License.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ProcTap will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#040-2025-01-20","title":"[0.4.0] - 2025-01-20","text":""},{"location":"changelog/#major-features","title":"\ud83c\udf89 Major Features","text":""},{"location":"changelog/#macos-screencapturekit-backend-official-support","title":"macOS ScreenCaptureKit Backend (Official Support)","text":"<ul> <li>Added ScreenCaptureKit backend for macOS 13.0+ (Ventura and later)</li> <li>Apple Silicon Compatible: No AMFI/SIP hacks required</li> <li>Simple Permissions: Screen Recording only (no Microphone/TCC complexity)</li> <li>BundleID-Based Capture: Automatically converts PID to bundleID</li> <li>Low Latency: ~10-15ms audio capture performance</li> <li>Stable API: Uses official Apple ScreenCaptureKit framework</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#macos-backend-architecture","title":"macOS Backend Architecture","text":"<ul> <li>ScreenCaptureKit is now the RECOMMENDED backend for macOS</li> <li>PyObjC backend moved to fallback (has IOProc callback issues)</li> <li>Swift CLI helper and C extension moved to <code>experimental/</code> directory</li> <li>macOS support upgraded from \"Experimental\" to \"Officially Supported\"</li> </ul>"},{"location":"changelog/#project-structure","title":"Project Structure","text":"<ul> <li>Relocated Swift helper: Moved from <code>swift/proctap-macos/</code> to <code>src/proctap/swift/screencapture-audio/</code></li> <li>Added MANIFEST.in: Ensures Swift helper is included in source distributions</li> <li>Archive directory: Created <code>archive/apple-silicon-investigation-20251120/</code> for historical investigation docs</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#type-safety","title":"Type Safety","text":"<ul> <li>Resolved all mypy type errors across the codebase</li> <li>Fixed type hints in macOS backends (ScreenCaptureKit, PyObjC, Native)</li> <li>Improved type annotations for better IDE support and static analysis</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":""},{"location":"changelog/#new-documentation","title":"New Documentation","text":"<ul> <li>macOS Investigation Archive: Comprehensive AMFI/SIP investigation docs in <code>archive/</code></li> <li>C Extension Investigation: Detailed findings in <code>docs/experimental/c_extension_investigation/</code></li> <li>Implementation Summaries: Session summaries and TCC implementation guides</li> </ul>"},{"location":"changelog/#updated-documentation","title":"Updated Documentation","text":"<ul> <li>README.md: Updated platform support table (macOS now \"Officially Supported\")</li> <li>CLAUDE.md: Updated macOS backend information and recommendations</li> <li>CI/CD workflows: Updated for ScreenCaptureKit backend builds</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":""},{"location":"changelog/#backend-selection-priority-macos","title":"Backend Selection Priority (macOS)","text":"<ol> <li>ScreenCaptureKit (Recommended - macOS 13+)</li> <li>PyObjC (Fallback - has IOProc callback issues)</li> <li>Swift CLI / C Extension (Archived - experimental only)</li> </ol>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>CI/CD workflows configured for ScreenCaptureKit backend</li> <li>Swift helper automatically built during installation (if Swift toolchain available)</li> <li>No breaking changes to existing Windows/Linux backends</li> </ul>"},{"location":"changelog/#migration-guide","title":"Migration Guide","text":""},{"location":"changelog/#for-macos-users","title":"For macOS Users","text":"<p>If you were using experimental backends: - Recommended: Switch to ScreenCaptureKit backend (default in v0.4.0) - Requirements: macOS 13.0+ and Screen Recording permission - No code changes needed: Existing code works with new backend - Bundle ID capture: Automatically handles PID \u2192 bundleID conversion</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>None for Windows/Linux users</li> <li>macOS: Experimental Swift CLI moved to <code>experimental/</code> (still available but not recommended)</li> </ul>"},{"location":"changelog/#031-2025-01-xx","title":"[0.3.1] - 2025-01-XX","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Documentation fixes and clarifications</li> </ul>"},{"location":"changelog/#030-2025-01-xx","title":"[0.3.0] - 2025-01-XX","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Full Linux support with PipeWire/PulseAudio backends</li> <li>Per-process audio isolation on Linux</li> <li>Graceful fallback chain: Native \u2192 PipeWire \u2192 PulseAudio</li> </ul>"},{"location":"changelog/#021-2025-01-xx","title":"[0.2.1] - 2025-01-XX","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Audio format conversion support</li> <li>Sample rate, channel, and bit depth conversion</li> <li>High-quality resampling with libsamplerate (optional)</li> </ul>"},{"location":"changelog/#020-2025-01-xx","title":"[0.2.0] - 2025-01-XX","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Linux backend implementation (experimental)</li> <li>macOS backend investigation started</li> </ul>"},{"location":"changelog/#011-2025-01-xx","title":"0.1.1 - 2025-01-XX","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Complete PyPI metadata (classifiers, keywords, project URLs)</li> <li>Comprehensive MkDocs documentation site</li> <li>GitHub issue templates (Bug Report, Feature Request, Performance, Type Hints, Documentation)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Renamed package from <code>processaudiotap</code> to <code>proctap</code> (PyPI: <code>proc-tap</code>)</li> <li>Improved README with status badges and structured contributing section</li> <li>Updated all documentation to English</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>PyPI badges now display correctly with proper classifiers</li> <li>TestPyPI installation instructions with correct index URLs</li> <li>GitHub Actions workflows split into build (Windows) and publish (Linux) jobs</li> </ul>"},{"location":"changelog/#010-2025-01-xx","title":"0.1.0 - 2025-01-XX","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release</li> <li>Per-process audio capture using WASAPI <code>ActivateAudioInterfaceAsync</code></li> <li>C++ native extension for high-performance audio capture</li> <li>Python API with callback and async iterator patterns</li> <li>Support for Windows 10/11 (20H1+)</li> <li>Support for Python 3.10, 3.11, 3.12, 3.13</li> <li>Fixed audio format: 44.1 kHz, stereo, 16-bit PCM</li> <li>Example scripts for recording to WAV</li> <li>Discord bot integration (contrib module)</li> <li>GitHub Actions workflows for building wheels</li> </ul>"},{"location":"changelog/#technical-details_1","title":"Technical Details","text":"<ul> <li>Native-only architecture (no Python fallback)</li> <li>Thread-safe audio capture</li> <li>Low-latency streaming (10ms buffer)</li> <li>No administrator privileges required</li> </ul>"},{"location":"changelog/#upcoming-features","title":"Upcoming Features","text":"<p>See our GitHub Issues for planned features and improvements.</p>"},{"location":"changelog/#planned-for-future-releases","title":"Planned for Future Releases","text":"<ul> <li> Configurable audio format (sample rate, channels, bit depth)</li> <li> Multiple process capture simultaneously</li> <li> Audio effects and filters</li> <li> Real-time audio analysis utilities</li> <li> More example integrations (OBS, streaming tools)</li> <li> Performance optimizations</li> <li> Comprehensive test suite</li> </ul>"},{"location":"changelog/#contributing","title":"Contributing","text":"<p>We welcome contributions! See our GitHub repository for details.</p>"},{"location":"macos_core_audio_research/","title":"macOS Core Audio API Research for Process-Based Audio Capture","text":"<p>Date: 2025-01-17 Status: Phase 1 - Research &amp; Prototyping Related Issue: #8</p>"},{"location":"macos_core_audio_research/#objective","title":"Objective","text":"<p>Replace the current Swift CLI helper approach with native PyObjC-based Core Audio API integration for process-specific audio capture on macOS 14.4+.</p>"},{"location":"macos_core_audio_research/#core-audio-apis-for-process-based-capture","title":"Core Audio APIs for Process-Based Capture","text":""},{"location":"macos_core_audio_research/#1-process-object-translation","title":"1. Process Object Translation","text":"<p>API: <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code></p> <pre><code># PyObjC usage\nfrom CoreAudio import (\n    kAudioObjectSystemObject,\n    kAudioHardwarePropertyTranslatePIDToProcessObject,\n    AudioObjectPropertyAddress,\n    AudioObjectGetPropertyData\n)\n\ndef get_process_object_from_pid(pid: int) -&gt; int:\n    \"\"\"\n    Translate process ID to Core Audio process object ID.\n\n    Args:\n        pid: Target process ID\n\n    Returns:\n        Process object ID (AudioObjectID)\n    \"\"\"\n    address = AudioObjectPropertyAddress()\n    address.mSelector = kAudioHardwarePropertyTranslatePIDToProcessObject\n    address.mScope = kAudioObjectPropertyScopeGlobal\n    address.mElement = kAudioObjectPropertyElementMain\n\n    # Input: PID (UInt32)\n    input_data = pid.to_bytes(4, 'little')\n\n    # Output: AudioObjectID\n    process_object_id = AudioObjectGetPropertyData(\n        kAudioObjectSystemObject,\n        address,\n        len(input_data),\n        input_data,\n        None  # Output size pointer\n    )\n\n    return process_object_id\n</code></pre>"},{"location":"macos_core_audio_research/#2-process-tap-creation","title":"2. Process Tap Creation","text":"<p>API: <code>AudioHardwareCreateProcessTap</code></p> <pre><code>from CoreAudio import (\n    AudioHardwareCreateProcessTap,\n    CATapDescription\n)\n\ndef create_process_tap(process_id: int, tap_type: int) -&gt; int:\n    \"\"\"\n    Create a tap for capturing audio from a process.\n\n    Args:\n        process_id: Core Audio process object ID\n        tap_type: Tap type (kCATapTypeInput or kCATapTypeOutput)\n\n    Returns:\n        Tap device ID (AudioDeviceID)\n    \"\"\"\n    # Create tap description\n    tap_desc = CATapDescription()\n    tap_desc.mProcessObjectID = process_id\n    tap_desc.mTapType = tap_type  # kCATapTypeOutput = 1 (playback)\n    tap_desc.mFormat = None  # Use default format\n\n    # Create tap\n    tap_device_id = AudioHardwareCreateProcessTap(tap_desc)\n\n    return tap_device_id\n</code></pre> <p>Constants: - <code>kCATapTypeInput = 0</code> - Capture microphone input from process - <code>kCATapTypeOutput = 1</code> - Capture playback output from process</p>"},{"location":"macos_core_audio_research/#3-audio-device-io","title":"3. Audio Device I/O","text":"<p>API: <code>AudioDeviceCreateIOProcID</code> and <code>AudioDeviceStart</code></p> <pre><code>from CoreAudio import (\n    AudioDeviceCreateIOProcID,\n    AudioDeviceStart,\n    AudioDeviceStop,\n    AudioDeviceDestroyIOProcID\n)\n\n# Callback function type\n# AudioDeviceIOProc = CFUNCTYPE(\n#     c_int,  # OSStatus\n#     c_uint,  # AudioDeviceID\n#     POINTER(AudioTimeStamp),\n#     POINTER(AudioBufferList),  # inInputData\n#     POINTER(AudioTimeStamp),  # inInputTime\n#     POINTER(AudioBufferList),  # outOutputData\n#     POINTER(AudioTimeStamp),  # inOutputTime\n#     c_void_p  # inClientData\n# )\n\ndef setup_audio_capture(device_id: int, callback):\n    \"\"\"\n    Setup audio capture from tap device.\n\n    Args:\n        device_id: Tap device ID from AudioHardwareCreateProcessTap\n        callback: Audio I/O callback function\n\n    Returns:\n        IOProcID for managing the callback\n    \"\"\"\n    # Create I/O Proc\n    io_proc_id = AudioDeviceCreateIOProcID(\n        device_id,\n        callback,\n        None  # client data (can pass Python object)\n    )\n\n    # Start audio I/O\n    AudioDeviceStart(device_id, io_proc_id)\n\n    return io_proc_id\n\ndef stop_audio_capture(device_id: int, io_proc_id: int):\n    \"\"\"Stop audio capture and cleanup.\"\"\"\n    AudioDeviceStop(device_id, io_proc_id)\n    AudioDeviceDestroyIOProcID(device_id, io_proc_id)\n</code></pre>"},{"location":"macos_core_audio_research/#4-audio-format-configuration","title":"4. Audio Format Configuration","text":"<p>API: <code>AudioStreamBasicDescription</code> (ASBD)</p> <pre><code>from CoreAudio import AudioStreamBasicDescription\n\ndef create_audio_format(sample_rate: float = 48000.0, channels: int = 2):\n    \"\"\"\n    Create audio format description for PCM capture.\n\n    Args:\n        sample_rate: Sample rate in Hz (default: 48000)\n        channels: Number of channels (default: 2)\n\n    Returns:\n        AudioStreamBasicDescription\n    \"\"\"\n    asbd = AudioStreamBasicDescription()\n    asbd.mSampleRate = sample_rate\n    asbd.mFormatID = kAudioFormatLinearPCM\n    asbd.mFormatFlags = (\n        kAudioFormatFlagIsSignedInteger |\n        kAudioFormatFlagIsPacked\n    )\n    asbd.mBitsPerChannel = 16\n    asbd.mChannelsPerFrame = channels\n    asbd.mBytesPerFrame = channels * 2  # 2 bytes per sample (16-bit)\n    asbd.mFramesPerPacket = 1\n    asbd.mBytesPerPacket = asbd.mBytesPerFrame * asbd.mFramesPerPacket\n    asbd.mReserved = 0\n\n    return asbd\n</code></pre>"},{"location":"macos_core_audio_research/#pyobjc-integration","title":"PyObjC Integration","text":""},{"location":"macos_core_audio_research/#installation","title":"Installation","text":"<pre><code>pip install pyobjc-core pyobjc-framework-CoreAudio\n</code></pre>"},{"location":"macos_core_audio_research/#import-structure","title":"Import Structure","text":"<pre><code># Core framework\nfrom Foundation import NSObject\nfrom CoreAudio import (\n    # System object\n    kAudioObjectSystemObject,\n    kAudioObjectPropertyScopeGlobal,\n    kAudioObjectPropertyElementMain,\n\n    # Properties\n    kAudioHardwarePropertyTranslatePIDToProcessObject,\n\n    # Functions\n    AudioObjectGetPropertyData,\n    AudioObjectSetPropertyData,\n    AudioHardwareCreateProcessTap,\n    AudioDeviceCreateIOProcID,\n    AudioDeviceStart,\n    AudioDeviceStop,\n    AudioDeviceDestroyIOProcID,\n\n    # Types\n    AudioObjectPropertyAddress,\n    AudioStreamBasicDescription,\n    AudioBufferList,\n    AudioTimeStamp,\n\n    # Format constants\n    kAudioFormatLinearPCM,\n    kAudioFormatFlagIsSignedInteger,\n    kAudioFormatFlagIsPacked,\n)\n</code></pre>"},{"location":"macos_core_audio_research/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"macos_core_audio_research/#current-swift-cli-helper","title":"Current: Swift CLI Helper","text":"<pre><code>Python Backend (macos.py)\n    \u2193 subprocess\nSwift Helper (proctap-macos binary)\n    \u2193 Swift/ObjC bridge\nCore Audio Process Tap API\n    \u2193\nTarget Process Audio\n</code></pre> <p>Overhead: - Subprocess creation/management: ~5-10ms - IPC via stdout: ~2-5ms - Total latency: ~7-15ms</p>"},{"location":"macos_core_audio_research/#proposed-pyobjc-direct","title":"Proposed: PyObjC Direct","text":"<pre><code>Python Backend (macos.py)\n    \u2193 PyObjC bridge\nCore Audio Process Tap API\n    \u2193\nTarget Process Audio\n</code></pre> <p>Overhead: - PyObjC bridge: ~1-3ms - Total latency: ~1-3ms</p> <p>Improvement: ~5-10ms latency reduction + simpler architecture</p>"},{"location":"macos_core_audio_research/#api-availability-requirements","title":"API Availability &amp; Requirements","text":""},{"location":"macos_core_audio_research/#macos-version-requirements","title":"macOS Version Requirements","text":"API Minimum macOS Version <code>AudioHardwareCreateProcessTap</code> macOS 14.4 (Sonoma) <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> macOS 10.5+ <code>AudioDeviceCreateIOProcID</code> macOS 10.4+"},{"location":"macos_core_audio_research/#permission-requirements","title":"Permission Requirements","text":"<p>Entitlement: <code>com.apple.security.device.audio-input</code></p> <p>Info.plist Keys: <pre><code>&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;ProcTap requires audio capture permission to record per-process audio.&lt;/string&gt;\n</code></pre></p> <p>Runtime Permission: First use will trigger macOS permission dialog.</p>"},{"location":"macos_core_audio_research/#prototype-implementation-plan","title":"Prototype Implementation Plan","text":""},{"location":"macos_core_audio_research/#phase-11-process-object-discovery-current","title":"Phase 1.1: Process Object Discovery (Current)","text":"<pre><code># File: src/proctap/backends/macos_pyobjc.py\n\ndef discover_process_audio_object(pid: int) -&gt; Optional[int]:\n    \"\"\"Find Core Audio object for process.\"\"\"\n    pass\n</code></pre>"},{"location":"macos_core_audio_research/#phase-12-tap-creation-format-configuration","title":"Phase 1.2: Tap Creation &amp; Format Configuration","text":"<pre><code>def create_tap_for_process(pid: int, sample_rate: int, channels: int):\n    \"\"\"Create audio tap with specified format.\"\"\"\n    pass\n</code></pre>"},{"location":"macos_core_audio_research/#phase-13-audio-callback-data-flow","title":"Phase 1.3: Audio Callback &amp; Data Flow","text":"<pre><code>def setup_capture_callback(on_data: Callable[[bytes, int], None]):\n    \"\"\"Setup I/O callback for audio capture.\"\"\"\n    pass\n</code></pre>"},{"location":"macos_core_audio_research/#phase-14-integration-testing","title":"Phase 1.4: Integration Testing","text":"<ul> <li>Test with Music.app, Safari, VLC, etc.</li> <li>Verify audio format negotiation</li> <li>Test permission handling</li> <li>Measure latency vs Swift helper</li> </ul>"},{"location":"macos_core_audio_research/#known-limitations-edge-cases","title":"Known Limitations &amp; Edge Cases","text":""},{"location":"macos_core_audio_research/#1-process-must-be-playing-audio","title":"1. Process Must Be Playing Audio","text":"<p>Core Audio Process Tap only works when: - Process has an active audio output stream - Process is not muted - Process is not paused</p> <p>Detection: Check for active <code>AudioDeviceIOProcID</code> on process object</p>"},{"location":"macos_core_audio_research/#2-format-negotiation","title":"2. Format Negotiation","text":"<p>Some processes may use non-standard formats: - 24-bit/32-bit float audio - 96kHz/192kHz sample rates - &gt;2 channel configurations</p> <p>Solution: Query tap device format, convert if needed</p>"},{"location":"macos_core_audio_research/#3-permission-dialog","title":"3. Permission Dialog","text":"<p>First run triggers system dialog: - Cannot be bypassed programmatically - User must grant permission - Permission persists in System Settings</p> <p>Handling: Detect permission denial, provide clear error messages</p>"},{"location":"macos_core_audio_research/#4-code-signing-distribution","title":"4. Code Signing (Distribution)","text":"<p>PyObjC apps don't require code signing for local use, but distribution via PyPI needs: - Hardened runtime entitlements - Notarization (for macOS 10.15+) - App-specific password for notarytool</p> <p>Solution: Document signing process, provide unsigned version for development</p>"},{"location":"macos_core_audio_research/#phase-1-results","title":"Phase 1 Results","text":""},{"location":"macos_core_audio_research/#completed-tasks","title":"Completed Tasks","text":"<ul> <li> Research Core Audio APIs - Documented all required APIs for process-based capture</li> <li> Create minimal PyObjC prototype - Implemented <code>ProcessAudioDiscovery</code> class in <code>macos_pyobjc.py</code></li> <li> Create test script - Built <code>examples/macos_pyobjc_test.py</code> for validation</li> <li> Update dependencies - Added PyObjC to <code>pyproject.toml</code> with platform markers</li> </ul>"},{"location":"macos_core_audio_research/#implementation-summary","title":"Implementation Summary","text":"<p>Files Created: 1. <code>src/proctap/backends/macos_pyobjc.py</code> - PyObjC prototype implementation 2. <code>examples/macos_pyobjc_test.py</code> - Test script for process discovery 3. <code>docs/macos_core_audio_research.md</code> - API research documentation</p> <p>Key Features Implemented: - Process ID \u2192 Core Audio Object ID translation - macOS version detection and Process Tap API availability check - Process audio output detection - Error handling and logging</p> <p>Dependencies Added: - <code>pyobjc-core&gt;=9.0</code> (macOS only, via <code>sys_platform == 'darwin'</code>) - <code>pyobjc-framework-CoreAudio&gt;=9.0</code> (macOS only)</p>"},{"location":"macos_core_audio_research/#testing-requirements-pending-requires-macos-144","title":"Testing Requirements (Pending - Requires macOS 14.4+)","text":"<p>\u26a0\ufe0f Note: This implementation was developed on Linux WSL2 and cannot be tested without a macOS 14.4+ system.</p> <p>Test Scenarios: <pre><code># Test with Music.app\npython examples/macos_pyobjc_test.py --name Music\n\n# Test with Safari\npython examples/macos_pyobjc_test.py --name Safari\n\n# Test with specific PID\npython examples/macos_pyobjc_test.py --pid 12345\n\n# List all processes with audio\npython examples/macos_pyobjc_test.py --list\n</code></pre></p> <p>Expected Behavior: - Should detect processes with active audio output - Should return <code>AudioObjectID</code> for valid processes - Should handle permission errors gracefully - Should fail gracefully for processes without audio</p>"},{"location":"macos_core_audio_research/#phase-2-planning","title":"Phase 2 Planning","text":"<p>Next Implementation Steps: 1. Audio Tap Creation - Implement <code>AudioHardwareCreateProcessTap</code> 2. I/O Callback Setup - Implement <code>AudioDeviceCreateIOProcID</code> and callback handler 3. Format Configuration - Configure <code>AudioStreamBasicDescription</code> for PCM capture 4. Buffer Management - Queue-based audio buffer handling 5. Integration - Replace Swift helper in <code>MacOSBackend</code> with PyObjC implementation</p> <p>Estimated Effort: - Phase 2: ~3-4 hours of development - Phase 3: ~2-3 hours of testing and bug fixes - Phase 4: Optional (C extension only if performance issues detected) - Phase 5: ~1-2 hours for migration and documentation</p> <p>Blocker: Testing requires actual macOS 14.4+ hardware/VM.</p>"},{"location":"macos_core_audio_research/#next-steps-phase-2-pending-macos-testing","title":"Next Steps (Phase 2 - Pending macOS Testing)","text":"<ul> <li> Test Phase 1 prototype on macOS 14.4+</li> <li> Fix any bugs discovered during testing</li> <li> Implement Process Tap creation (Phase 2.1)</li> <li> Implement I/O callback and audio streaming (Phase 2.2)</li> <li> Document Phase 1 results and proceed to Phase 2</li> </ul>"},{"location":"macos_core_audio_research/#references","title":"References","text":"<ol> <li>Core Audio Overview - Apple Developer</li> <li>Audio Hardware Services - Apple Developer</li> <li>PyObjC Documentation</li> <li>Process Tap API - WWDC 2023</li> <li>AudioHardwareCreateProcessTap Reference</li> </ol> <p>Author: Claude (AI Assistant) Last Updated: 2025-01-17</p>"},{"location":"macos_include_exclude_pids_implementation/","title":"macOS Core Audio Process Tap - Include/Exclude PIDs Implementation","text":"<p>Date: 2025-11-18 Status: \u2705 Completed Related Issue: User request for advanced PID filtering</p>"},{"location":"macos_include_exclude_pids_implementation/#summary","title":"Summary","text":"<p>Implemented advanced PID filtering for the macOS Core Audio Process Tap backend, allowing users to capture audio from multiple specific processes or exclude specific processes from capture.</p>"},{"location":"macos_include_exclude_pids_implementation/#features-implemented","title":"Features Implemented","text":""},{"location":"macos_include_exclude_pids_implementation/#1-swift-cli-helper-enhancements","title":"1. Swift CLI Helper Enhancements","text":"<p>File: <code>swift/proctap-macos/Sources/main.swift</code></p>"},{"location":"macos_include_exclude_pids_implementation/#new-command-line-arguments","title":"New Command-Line Arguments","text":"<ul> <li><code>--include-pids &lt;PIDs&gt;</code>: Comma-separated list of PIDs to capture audio from</li> <li><code>--exclude-pids &lt;PIDs&gt;</code>: Comma-separated list of PIDs to exclude from capture</li> <li><code>--pid &lt;PID&gt;</code>: Legacy single PID support (converted to <code>--include-pids</code> internally)</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#core-audio-integration","title":"Core Audio Integration","text":"<ul> <li>Implemented PID to AudioObjectID translation using <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code></li> <li>Used <code>CATapDescription</code> Objective-C initializers:</li> <li><code>initStereoMixdownOfProcesses:</code> - Capture from specific processes (stereo)</li> <li><code>initMonoMixdownOfProcesses:</code> - Capture from specific processes (mono)</li> <li><code>initStereoGlobalTapButExcludeProcesses:</code> - Capture all except specified (stereo)</li> <li><code>initMonoGlobalTapButExcludeProcesses:</code> - Capture all except specified (mono)</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#key-implementation-details","title":"Key Implementation Details","text":"<pre><code>// Convert PIDs to AudioObjectIDs\nvar includeObjects: [AudioObjectID] = []\nfor pid in includePIDs {\n    let obj = try getProcessObject(for: pid)\n    includeObjects.append(obj)\n}\n\n// Create tap description based on configuration\nif !excludeProcesses.isEmpty {\n    tapDesc = CATapDescription.init(stereoGlobalTapButExcludeProcesses: excludeProcesses)\n} else if !includeProcesses.isEmpty {\n    tapDesc = CATapDescription.init(stereoMixdownOfProcesses: includeProcesses)\n}\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#signal-handling","title":"Signal Handling","text":"<ul> <li>Implemented SIGINT/SIGTERM handlers for graceful cleanup</li> <li>Ensures AudioHardwareDestroyProcessTap is called on exit</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#2-python-backend-enhancements","title":"2. Python Backend Enhancements","text":"<p>File: <code>src/proctap/backends/macos.py</code></p>"},{"location":"macos_include_exclude_pids_implementation/#new-parameters","title":"New Parameters","text":"<pre><code>class MacOSBackend(AudioBackend):\n    def __init__(\n        self,\n        pid: int,\n        sample_rate: int = 48000,\n        channels: int = 2,\n        sample_width: int = 2,\n        include_pids: Optional[list[int]] = None,  # NEW\n        exclude_pids: Optional[list[int]] = None,  # NEW\n        device: Optional[str] = None,              # NEW\n    ) -&gt; None:\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li><code>pid</code> parameter maintained for backward compatibility</li> <li>If <code>include_pids</code> is <code>None</code> and <code>pid &gt; 0</code>, it's converted to <code>include_pids=[pid]</code></li> <li>If both are <code>None</code> or <code>pid=0</code>, captures all processes</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#command-building","title":"Command Building","text":"<pre><code>cmd = [str(self._helper_path), \"--sample-rate\", str(self._sample_rate), \"--channels\", str(self._channels)]\n\nif self._include_pids:\n    cmd.extend([\"--include-pids\", \",\".join(map(str, self._include_pids))])\n\nif self._exclude_pids:\n    cmd.extend([\"--exclude-pids\", \",\".join(map(str, self._exclude_pids))])\n\nif self._device:\n    cmd.extend([\"--device\", self._device])\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#3-examples","title":"3. Examples","text":""},{"location":"macos_include_exclude_pids_implementation/#basic-example-updated","title":"Basic Example (Updated)","text":"<p>File: <code>examples/macos_basic.py</code></p> <ul> <li>Demonstrates single process capture</li> <li>Backward compatible with existing API</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#advanced-example-new","title":"Advanced Example (NEW)","text":"<p>File: <code>examples/macos_advanced.py</code></p> <ul> <li>Demonstrates multi-process capture</li> <li>Shows include/exclude PIDs usage</li> <li>Supports process name resolution via psutil</li> </ul> <p>Usage Examples:</p> <pre><code># Capture from multiple specific processes\npython macos_advanced.py --include-pids 1234,5678 --duration 5 --output multi.wav\n\n# Capture all except music player\npython macos_advanced.py --exclude-pids 9999 --duration 10 --output no_music.wav\n\n# Capture game + voice chat, exclude music (by name)\npython macos_advanced.py --include-names \"game,discord\" --exclude-names \"Music\" --duration 10\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#technical-details","title":"Technical Details","text":""},{"location":"macos_include_exclude_pids_implementation/#type-conversion-fix","title":"Type Conversion Fix","text":"<p>Fixed compilation errors related to <code>CATapDescription</code> initializers:</p> <ul> <li>Problem: Initial implementation used <code>[NSNumber]</code> arrays</li> <li>Solution: Changed to <code>[AudioObjectID]</code> (which is <code>[UInt32]</code>)</li> <li>Reason: <code>CATapDescription</code> initializers are marked with <code>NS_REFINED_FOR_SWIFT</code> and expect native Swift types</li> </ul> <pre><code>// Before (FAILED)\nvar includeObjects: [NSNumber] = []\nincludeObjects.append(NSNumber(value: obj))\n\n// After (SUCCESS)\nvar includeObjects: [AudioObjectID] = []\nincludeObjects.append(obj)\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#availability-annotations","title":"Availability Annotations","text":"<p>Fixed global variable availability issues:</p> <pre><code>// Before (FAILED)\n@available(macOS 14.2, *)\nvar tapInstance: ProcessAudioTap?\n\n// After (SUCCESS)\nvar tapInstance: Any?  // Type-erased to avoid availability annotation on global\n\n// Usage in signal handlers\nif #available(macOS 14.2, *) {\n    (tapInstance as? ProcessAudioTap)?.stop()\n}\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#build-deployment","title":"Build &amp; Deployment","text":""},{"location":"macos_include_exclude_pids_implementation/#build-commands","title":"Build Commands","text":"<pre><code># Build Swift CLI helper\ncd swift/proctap-macos\nswift build -c release\n\n# Copy to package directory\ncp .build/release/proctap-macos ../../src/proctap/bin/\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#build-output","title":"Build Output","text":"<ul> <li>Binary size: ~111KB</li> <li>Build time: ~1.2s</li> <li>Platform: macOS arm64</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#build-warnings","title":"Build Warnings","text":"<p>Minor warning (safe to ignore): <pre><code>warning: forming 'UnsafeMutableRawPointer' to a variable of type 'CFString'\n</code></pre></p> <p>This is a common pattern in Core Audio code and does not affect functionality.</p>"},{"location":"macos_include_exclude_pids_implementation/#testing","title":"Testing","text":""},{"location":"macos_include_exclude_pids_implementation/#manual-testing-performed","title":"Manual Testing Performed","text":"<ol> <li>\u2705 Swift helper compiles without errors</li> <li>\u2705 Binary runs and shows correct help message</li> <li>\u2705 Python backend finds helper binary correctly</li> <li>\u2705 <code>MacOSBackend</code> initialization with include/exclude PIDs works</li> <li>\u2705 Command building logic produces correct arguments</li> </ol>"},{"location":"macos_include_exclude_pids_implementation/#testing-requirements","title":"Testing Requirements","text":"<p>\u26a0\ufe0f Note: Full end-to-end testing requires: - macOS 14.4+ (Sonoma) or later - Processes actively playing audio - Audio capture permission granted</p> <p>Test Scenarios:</p> <pre><code># Test single process capture\npython examples/macos_basic.py --pid &lt;PID&gt; --duration 5 --output test.wav\n\n# Test multi-process capture\npython examples/macos_advanced.py --include-pids &lt;PID1&gt;,&lt;PID2&gt; --duration 5 --output multi.wav\n\n# Test exclude mode\npython examples/macos_advanced.py --exclude-pids &lt;PID&gt; --duration 5 --output exclude.wav\n\n# Test by process name\npython examples/macos_advanced.py --include-names \"Safari,Music\" --duration 10 --output named.wav\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#use-cases","title":"Use Cases","text":""},{"location":"macos_include_exclude_pids_implementation/#1-game-voice-chat-capture","title":"1. Game + Voice Chat Capture","text":"<pre><code>backend = MacOSBackend(\n    pid=0,\n    include_pids=[game_pid, discord_pid],\n    exclude_pids=[music_pid],\n    sample_rate=48000,\n    channels=2\n)\n</code></pre> <p>Captures audio from game and Discord voice chat while excluding background music.</p>"},{"location":"macos_include_exclude_pids_implementation/#2-exclude-music-player","title":"2. Exclude Music Player","text":"<pre><code>backend = MacOSBackend(\n    pid=0,\n    exclude_pids=[music_app_pid],\n    sample_rate=16000,\n    channels=1\n)\n</code></pre> <p>Captures all system audio except music player (useful for voice recording).</p>"},{"location":"macos_include_exclude_pids_implementation/#3-multiple-app-capture","title":"3. Multiple App Capture","text":"<pre><code>backend = MacOSBackend(\n    pid=0,\n    include_pids=[safari_pid, chrome_pid, firefox_pid],\n    sample_rate=44100,\n    channels=2\n)\n</code></pre> <p>Captures audio only from web browsers.</p>"},{"location":"macos_include_exclude_pids_implementation/#known-limitations","title":"Known Limitations","text":"<ol> <li>Process Must Be Playing Audio: Core Audio Process Tap only works when processes have active audio output streams</li> <li>macOS 14.4+ Required: Process Tap API is only available on macOS 14.4 (Sonoma) or later</li> <li>Permission Required: First run triggers macOS audio capture permission dialog</li> <li>Max PIDs: While the API doesn't enforce a hard limit, performance may degrade with many PIDs</li> </ol>"},{"location":"macos_include_exclude_pids_implementation/#files-modified","title":"Files Modified","text":""},{"location":"macos_include_exclude_pids_implementation/#new-files","title":"New Files","text":"<ul> <li><code>examples/macos_advanced.py</code> - Advanced usage example</li> <li><code>docs/macos_include_exclude_pids_implementation.md</code> - This document</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#modified-files","title":"Modified Files","text":"<ul> <li><code>swift/proctap-macos/Sources/main.swift</code> - Full rewrite with include/exclude support</li> <li><code>src/proctap/backends/macos.py</code> - Added include_pids, exclude_pids, device parameters</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#binary-output","title":"Binary Output","text":"<ul> <li><code>src/proctap/bin/proctap-macos</code> - Built Swift CLI helper (111KB)</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#compatibility","title":"Compatibility","text":""},{"location":"macos_include_exclude_pids_implementation/#backward-compatibility_1","title":"Backward Compatibility","text":"<p>\u2705 Fully backward compatible with existing code:</p> <pre><code># Old code (still works)\nbackend = MacOSBackend(pid=1234, sample_rate=48000, channels=2)\n\n# New code\nbackend = MacOSBackend(\n    pid=0,\n    include_pids=[1234, 5678],\n    exclude_pids=[9999],\n    sample_rate=48000,\n    channels=2\n)\n</code></pre>"},{"location":"macos_include_exclude_pids_implementation/#api-compatibility","title":"API Compatibility","text":"<ul> <li>Old <code>pid</code> parameter preserved</li> <li>New parameters are optional (<code>None</code> by default)</li> <li>If both <code>pid</code> and <code>include_pids</code> are specified, <code>include_pids</code> takes precedence</li> </ul>"},{"location":"macos_include_exclude_pids_implementation/#future-improvements","title":"Future Improvements","text":"<ol> <li>Dynamic PID Management: Add/remove PIDs during capture</li> <li>PID Auto-Discovery: Automatically find processes playing audio</li> <li>Process Name Support: Built-in process name \u2192 PID resolution</li> <li>Format Negotiation: Query tap device format and adapt automatically</li> <li>Error Recovery: Reconnect if process restarts</li> <li>Metrics: Track per-process audio levels and statistics</li> </ol>"},{"location":"macos_include_exclude_pids_implementation/#references","title":"References","text":"<ol> <li>Core Audio Process Tap API - Apple Developer</li> <li>CATapDescription - Core Audio Header</li> <li>GitHub Issue #8 - PyObjC Backend Research</li> </ol> <p>Implementation Author: Claude (AI Assistant) Implementation Date: 2025-11-18 Status: \u2705 Complete and ready for testing</p>"},{"location":"api/processaudiotap/","title":"ProcessAudioCapture","text":""},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture","title":"<code>ProcessAudioCapture</code>","text":"<p>High-level API for process-specific audio capture.</p> <p>All captured audio is returned in standard format: - Sample rate: 48000 Hz - Channels: 2 (stereo) - Sample format: float32 (IEEE 754, normalized to [-1.0, 1.0])</p> <p>Supports multiple platforms: - Windows: WASAPI Process Loopback (fully implemented) - Linux: PulseAudio/PipeWire (experimental) - macOS: Core Audio (experimental)</p> <p>Usage: - Callback mode: start(on_data=callback) - Async mode: async for chunk in tap.iter_chunks()</p> Source code in <code>src/proctap/core.py</code> <pre><code>class ProcessAudioCapture:\n    \"\"\"\n    High-level API for process-specific audio capture.\n\n    All captured audio is returned in standard format:\n    - Sample rate: 48000 Hz\n    - Channels: 2 (stereo)\n    - Sample format: float32 (IEEE 754, normalized to [-1.0, 1.0])\n\n    Supports multiple platforms:\n    - Windows: WASAPI Process Loopback (fully implemented)\n    - Linux: PulseAudio/PipeWire (experimental)\n    - macOS: Core Audio (experimental)\n\n    Usage:\n    - Callback mode: start(on_data=callback)\n    - Async mode: async for chunk in tap.iter_chunks()\n    \"\"\"\n\n    def __init__(\n        self,\n        pid: int,\n        on_data: Optional[AudioCallback] = None,\n        resample_quality: ResampleQuality = 'best',\n    ) -&gt; None:\n        \"\"\"\n        Initialize process audio capture.\n\n        Args:\n            pid: Process ID to capture audio from\n            on_data: Optional callback for audio data (callback mode)\n            resample_quality: Resampling quality mode when format conversion is needed\n                - 'best': Highest quality, ~1.3-1.4ms latency (default)\n                - 'medium': Medium quality, ~0.7-0.9ms latency\n                - 'fast': Lowest quality, ~0.3-0.5ms latency\n        \"\"\"\n        self._pid = pid\n        self._on_data = on_data\n        self._resample_quality = resample_quality\n\n        # Get platform-specific backend (always returns standard format)\n        self._backend: AudioBackend = get_backend(pid=pid, resample_quality=resample_quality)\n\n        logger.debug(f\"Using backend: {type(self._backend).__name__}\")\n        logger.debug(f\"Standard format: {STANDARD_SAMPLE_RATE}Hz, {STANDARD_CHANNELS}ch, {STANDARD_FORMAT}\")\n\n        self._thread: Optional[threading.Thread] = None\n        self._stop_event = threading.Event()\n        self._async_queue: \"queue.Queue[bytes | None]\" = queue.Queue()\n\n    # --- public API -----------------------------------------------------\n\n    def start(self) -&gt; None:\n        if self._thread is not None:\n            # \u3059\u3067\u306b start \u6e08\u307f\u306a\u3089\u4f55\u3082\u3057\u306a\u3044\n            return\n\n        # Start platform-specific backend\n        self._backend.start()\n\n        self._stop_event.clear()\n        self._thread = threading.Thread(target=self._worker, daemon=True)\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        self._stop_event.set()\n\n        if self._thread is not None:\n            self._thread.join(timeout=1.0)\n            self._thread = None\n\n        try:\n            self._backend.stop()\n        except Exception:\n            logger.exception(\"Error while stopping capture\")\n\n    def close(self) -&gt; None:\n        self.stop()\n\n    def __enter__(self) -&gt; \"ProcessAudioCapture\":\n        self.start()\n        return self\n\n    def __exit__(self, _exc_type, _exc, _tb) -&gt; None:\n        self.close()\n\n    # --- properties -----------------------------------------------------\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if audio capture is currently running.\"\"\"\n        return self._thread is not None and self._thread.is_alive()\n\n    @property\n    def pid(self) -&gt; int:\n        \"\"\"Get the target process ID.\"\"\"\n        return self._pid\n\n    @property\n    def format(self) -&gt; dict[str, int | str]:\n        \"\"\"\n        Get the audio format information (always returns standard format).\n\n        Returns:\n            Dictionary with:\n            - 'sample_rate': 48000\n            - 'channels': 2\n            - 'bits_per_sample': 32\n            - 'sample_format': 'float32'\n        \"\"\"\n        return {\n            'sample_rate': STANDARD_SAMPLE_RATE,\n            'channels': STANDARD_CHANNELS,\n            'bits_per_sample': STANDARD_SAMPLE_WIDTH * 8,\n            'sample_format': STANDARD_FORMAT,\n        }\n\n    # --- utility methods ------------------------------------------------\n\n    def set_callback(self, callback: Optional[AudioCallback]) -&gt; None:\n        \"\"\"\n        Change the audio data callback.\n\n        Args:\n            callback: New callback function, or None to remove callback\n        \"\"\"\n        self._on_data = callback\n\n    def get_format(self) -&gt; dict[str, int | str]:\n        \"\"\"\n        Get audio format information from the backend.\n\n        Returns:\n            Dictionary with keys:\n            - 'sample_rate': 48000\n            - 'channels': 2\n            - 'bits_per_sample': 32\n            - 'sample_format': 'float32'\n        \"\"\"\n        return self._backend.get_format()\n\n    def read(self, timeout: float = 1.0) -&gt; Optional[bytes]:\n        \"\"\"\n        Synchronous API: Read one audio chunk (blocking).\n\n        Args:\n            timeout: Maximum time to wait for data in seconds\n\n        Returns:\n            PCM audio data as bytes (48kHz/2ch/float32), or None if timeout or no data\n\n        Note:\n            This is a simple synchronous alternative to the async API.\n            The capture must be started first with start().\n        \"\"\"\n        if not self.is_running:\n            raise RuntimeError(\"Capture is not running. Call start() first.\")\n\n        try:\n            return self._async_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n\n    # --- async interface ------------------------------------------------\n\n    async def iter_chunks(self) -&gt; AsyncIterator[bytes]:\n        \"\"\"\n        Async generator that yields PCM chunks as bytes.\n        All chunks are in standard format: 48kHz/2ch/float32.\n        \"\"\"\n        loop = asyncio.get_running_loop()\n\n        while True:\n            chunk = await loop.run_in_executor(None, self._async_queue.get)\n            if chunk is None:  # sentinel\n                break\n            yield chunk\n\n    # --- worker thread --------------------------------------------------\n\n    def _worker(self) -&gt; None:\n        \"\"\"\n        Loop:\n            data = backend.read()\n            -&gt; callback\n            -&gt; async_queue\n        \"\"\"\n        while not self._stop_event.is_set():\n            try:\n                data = self._backend.read()\n            except Exception:\n                logger.exception(\"Error reading data from backend\")\n                continue\n\n            if not data:\n                # \u30d1\u30b1\u30c3\u30c8\u304c\u307e\u3060\u7121\u3044\u30b1\u30fc\u30b9\u3002\u3053\u3053\u3067 sleep \u5165\u308c\u308b\u304b\u306f\u5f8c\u3067\u8abf\u6574\u3002\n                continue\n\n            # callback\n            if self._on_data is not None:\n                try:\n                    # frames \u6570\u306f backend \u304b\u3089\u76f4\u63a5\u53d6\u308c\u306a\u3044\u306e\u3067\u3001\u3068\u308a\u3042\u3048\u305a -1 \u3092\u6e21\u3059\u3002\n                    # TODO: calculate frame count from data length and format\n                    self._on_data(data, -1)\n                except Exception:\n                    logger.exception(\"Error in audio callback\")\n\n            # async queue\n            try:\n                self._async_queue.put_nowait(data)\n            except queue.Full:\n                # \u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u6027\u91cd\u8996\u306a\u306e\u3067\u6368\u3066\u308b\n                pass\n\n        # \u7d42\u4e86\u30b7\u30b0\u30ca\u30eb\n        try:\n            self._async_queue.put_nowait(None)\n        except queue.Full:\n            pass\n</code></pre>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.format","title":"<code>format</code>  <code>property</code>","text":"<p>Get the audio format information (always returns standard format).</p> <p>Returns:</p> Type Description <code>dict[str, int | str]</code> <p>Dictionary with:</p> <code>dict[str, int | str]</code> <ul> <li>'sample_rate': 48000</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'channels': 2</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'bits_per_sample': 32</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'sample_format': 'float32'</li> </ul>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio capture is currently running.</p>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.pid","title":"<code>pid</code>  <code>property</code>","text":"<p>Get the target process ID.</p>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.__init__","title":"<code>__init__(pid, on_data=None, resample_quality='best')</code>","text":"<p>Initialize process audio capture.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>Process ID to capture audio from</p> required <code>on_data</code> <code>Optional[AudioCallback]</code> <p>Optional callback for audio data (callback mode)</p> <code>None</code> <code>resample_quality</code> <code>ResampleQuality</code> <p>Resampling quality mode when format conversion is needed - 'best': Highest quality, ~1.3-1.4ms latency (default) - 'medium': Medium quality, ~0.7-0.9ms latency - 'fast': Lowest quality, ~0.3-0.5ms latency</p> <code>'best'</code> Source code in <code>src/proctap/core.py</code> <pre><code>def __init__(\n    self,\n    pid: int,\n    on_data: Optional[AudioCallback] = None,\n    resample_quality: ResampleQuality = 'best',\n) -&gt; None:\n    \"\"\"\n    Initialize process audio capture.\n\n    Args:\n        pid: Process ID to capture audio from\n        on_data: Optional callback for audio data (callback mode)\n        resample_quality: Resampling quality mode when format conversion is needed\n            - 'best': Highest quality, ~1.3-1.4ms latency (default)\n            - 'medium': Medium quality, ~0.7-0.9ms latency\n            - 'fast': Lowest quality, ~0.3-0.5ms latency\n    \"\"\"\n    self._pid = pid\n    self._on_data = on_data\n    self._resample_quality = resample_quality\n\n    # Get platform-specific backend (always returns standard format)\n    self._backend: AudioBackend = get_backend(pid=pid, resample_quality=resample_quality)\n\n    logger.debug(f\"Using backend: {type(self._backend).__name__}\")\n    logger.debug(f\"Standard format: {STANDARD_SAMPLE_RATE}Hz, {STANDARD_CHANNELS}ch, {STANDARD_FORMAT}\")\n\n    self._thread: Optional[threading.Thread] = None\n    self._stop_event = threading.Event()\n    self._async_queue: \"queue.Queue[bytes | None]\" = queue.Queue()\n</code></pre>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.get_format","title":"<code>get_format()</code>","text":"<p>Get audio format information from the backend.</p> <p>Returns:</p> Type Description <code>dict[str, int | str]</code> <p>Dictionary with keys:</p> <code>dict[str, int | str]</code> <ul> <li>'sample_rate': 48000</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'channels': 2</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'bits_per_sample': 32</li> </ul> <code>dict[str, int | str]</code> <ul> <li>'sample_format': 'float32'</li> </ul> Source code in <code>src/proctap/core.py</code> <pre><code>def get_format(self) -&gt; dict[str, int | str]:\n    \"\"\"\n    Get audio format information from the backend.\n\n    Returns:\n        Dictionary with keys:\n        - 'sample_rate': 48000\n        - 'channels': 2\n        - 'bits_per_sample': 32\n        - 'sample_format': 'float32'\n    \"\"\"\n    return self._backend.get_format()\n</code></pre>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.iter_chunks","title":"<code>iter_chunks()</code>  <code>async</code>","text":"<p>Async generator that yields PCM chunks as bytes. All chunks are in standard format: 48kHz/2ch/float32.</p> Source code in <code>src/proctap/core.py</code> <pre><code>async def iter_chunks(self) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Async generator that yields PCM chunks as bytes.\n    All chunks are in standard format: 48kHz/2ch/float32.\n    \"\"\"\n    loop = asyncio.get_running_loop()\n\n    while True:\n        chunk = await loop.run_in_executor(None, self._async_queue.get)\n        if chunk is None:  # sentinel\n            break\n        yield chunk\n</code></pre>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.read","title":"<code>read(timeout=1.0)</code>","text":"<p>Synchronous API: Read one audio chunk (blocking).</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait for data in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>PCM audio data as bytes (48kHz/2ch/float32), or None if timeout or no data</p> Note <p>This is a simple synchronous alternative to the async API. The capture must be started first with start().</p> Source code in <code>src/proctap/core.py</code> <pre><code>def read(self, timeout: float = 1.0) -&gt; Optional[bytes]:\n    \"\"\"\n    Synchronous API: Read one audio chunk (blocking).\n\n    Args:\n        timeout: Maximum time to wait for data in seconds\n\n    Returns:\n        PCM audio data as bytes (48kHz/2ch/float32), or None if timeout or no data\n\n    Note:\n        This is a simple synchronous alternative to the async API.\n        The capture must be started first with start().\n    \"\"\"\n    if not self.is_running:\n        raise RuntimeError(\"Capture is not running. Call start() first.\")\n\n    try:\n        return self._async_queue.get(timeout=timeout)\n    except queue.Empty:\n        return None\n</code></pre>"},{"location":"api/processaudiotap/#proctap.ProcessAudioCapture.set_callback","title":"<code>set_callback(callback)</code>","text":"<p>Change the audio data callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Optional[AudioCallback]</code> <p>New callback function, or None to remove callback</p> required Source code in <code>src/proctap/core.py</code> <pre><code>def set_callback(self, callback: Optional[AudioCallback]) -&gt; None:\n    \"\"\"\n    Change the audio data callback.\n\n    Args:\n        callback: New callback function, or None to remove callback\n    \"\"\"\n    self._on_data = callback\n</code></pre>"},{"location":"experimental/c_extension_investigation/","title":"macOS C Extension Investigation (Archived)","text":"<p>Date: 2025-11-18 Status: Archived - API unavailability confirmed</p>"},{"location":"experimental/c_extension_investigation/#overview","title":"Overview","text":"<p>This directory contains the investigation and refactoring work for the macOS C extension backend using Core Audio Process Tap API.</p>"},{"location":"experimental/c_extension_investigation/#investigation-summary","title":"Investigation Summary","text":"<p>All three macOS backend implementations (Swift CLI, C Extension, PyObjC) failed due to the <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> API being unavailable on macOS 14.6 (Darwin 24.6.0).</p>"},{"location":"experimental/c_extension_investigation/#key-findings","title":"Key Findings","text":"<ol> <li>Aggregate Device Approach (Original):</li> <li>Process Tap created successfully (tapID=118)</li> <li>Aggregate Device created successfully (device_id=120)</li> <li>IOProc invoked but received <code>inBuffers=0, outBuffers=1</code></li> <li> <p>Result: 0 bytes captured</p> </li> <li> <p>Direct Tap Approach (Refactored):</p> </li> <li>Removed all Aggregate Device code</li> <li>Attached IOProc directly to Process Tap</li> <li>Architecturally correct implementation</li> <li> <p>Result: Blocked by PID\u2192AudioObjectID translation API unavailability</p> </li> <li> <p>PyObjC Backend:</p> </li> <li>Never used Aggregate Device (correct from the start)</li> <li>Also blocked by the same API unavailability</li> </ol>"},{"location":"experimental/c_extension_investigation/#files-in-this-archive","title":"Files in This Archive","text":"<ul> <li>FINDINGS.md - Comprehensive investigation report with timeline</li> <li>DEBUG_LOG.md - Detailed test logs showing Aggregate Device approach behavior</li> <li>test_tap_direct.py - Test script for direct tap attachment</li> <li>debug_device_streams.py - Script to query aggregate device stream configuration</li> <li>test_native_simple.py - Simple native backend test</li> <li>test_native_backend.py - Native backend integration test</li> <li>fix_summary.md - Summary of PID\u2192AudioObjectID fix attempt</li> </ul>"},{"location":"experimental/c_extension_investigation/#lessons-learned","title":"Lessons Learned","text":""},{"location":"experimental/c_extension_investigation/#correct-architecture","title":"Correct Architecture","text":"<p>The correct approach for Process Tap API is: <pre><code>Process Tap (tap_id) \u2192 IOProc (direct) \u2192 Ring Buffer \u2192 Python\n</code></pre></p> <p>NOT: <pre><code>Process Tap \u2192 Aggregate Device \u2192 IOProc (wrong)\n</code></pre></p>"},{"location":"experimental/c_extension_investigation/#api-requirements","title":"API Requirements","text":"<p>Core Audio Process Tap API requires: 1. <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> for PID\u2192AudioObjectID translation 2. <code>AudioHardwareCreateProcessTap</code> for tap creation 3. <code>AudioDeviceCreateIOProcID</code> for IOProc attachment 4. Process must be actively playing audio</p>"},{"location":"experimental/c_extension_investigation/#implementation-status","title":"Implementation Status","text":"<ul> <li>Refactored C Extension: Architecturally correct, compiles successfully</li> <li>PID\u2192AudioObjectID Fix: Properly implemented with correct memory management</li> <li>Functionality: Blocked by macOS API unavailability</li> </ul>"},{"location":"experimental/c_extension_investigation/#recommendation","title":"Recommendation","text":"<p>\u274c Do NOT continue with Process Tap API approach</p> <p>\u2705 Alternative Solutions: 1. BlackHole + Loopback Audio - Proven, reliable, works on all macOS versions 2. Screen Capture Kit Audio (macOS 13+) - Official API with process isolation 3. AudioServerPlugin - Low-level but complex 4. Virtual Audio Devices - Redirect per-process via Multi-Output Device</p>"},{"location":"experimental/c_extension_investigation/#related-commits","title":"Related Commits","text":"<ul> <li><code>d79b26a</code> - Adopted PyObjC as official backend</li> <li>Current refactoring work (not committed)</li> </ul>"},{"location":"experimental/c_extension_investigation/#code-location","title":"Code Location","text":"<p>The refactored C extension is at: - <code>src/proctap/_native_macos.m</code> (current - may be reverted) - <code>src/proctap/experimental/_native_macos.m</code> (backup of refactored version)</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/","title":"Final Conclusion: macOS Process Tap API Investigation","text":""},{"location":"experimental/c_extension_investigation/CONCLUSION/#executive-summary","title":"Executive Summary","text":"<p>Result: All macOS backend implementations (Swift CLI, C Extension, PyObjC) are non-functional on macOS 14.6 (Darwin 24.6.0).</p> <p>Root Cause: The Core Audio Process Tap API is either: 1. Not fully implemented in macOS 14.6 2. Requires undocumented permissions/entitlements 3. Has incompatible SDK definitions across macOS versions 4. Was never actually tested and verified working</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#evidence","title":"Evidence","text":""},{"location":"experimental/c_extension_investigation/CONCLUSION/#1-swift-cli-commits-8d78147-d1f53b0","title":"1. Swift CLI (commits 8d78147, d1f53b0)","text":"<p>Compilation Status: \u274c FAILED</p> <p>Errors: <pre><code>error: value of type 'CATapDescription' has no member 'mIncludeProcesses'\nerror: value of type 'CATapDescription' has no member 'mProcessingType'\nerror: cannot find 'kAudioTapProcessingTypeMixDown' in scope\nerror: value of type 'CATapDescription' has no member 'mMuteBehavior'\n</code></pre></p> <p>Analysis: - Code assumes <code>CATapDescription</code> structure members that don't exist in current SDK - API definitions changed between SDK versions or were never public - Cannot compile on current macOS 14.6 SDK</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#2-pyobjc-backend-commit-d79b26a","title":"2. PyObjC Backend (commit d79b26a)","text":"<p>Status: Marked as \"Phase 3 - Official macOS Backend (Verified Working)\" \u26a0\ufe0f</p> <p>Reality: - Documentation shows \"Testing Requirements (Pending - Requires macOS 14.4+)\" - No evidence of actual testing or verification - Uses <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> API - API unavailable: <code>AudioObjectHasProperty</code> returns False</p> <p>Test Results: <pre><code>has_property = _AudioObjectHasProperty(\n    kAudioObjectSystemObject,\n    byref(address)  # kAudioHardwarePropertyTranslatePIDToProcessObject\n)\n# Returns: False (property not available)\n</code></pre></p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#3-c-extension-original-with-aggregate-device","title":"3. C Extension (Original with Aggregate Device)","text":"<p>Status: Creates devices successfully, captures 0 bytes</p> <p>Test Results: <pre><code>[DEBUG] Process tap created with ID: 118 \u2705\n[DEBUG] Aggregate device created successfully (ID: 119) \u2705\n[DEBUG] IOProcID created for aggregate device 119 \u2705\n[DEBUG] Aggregate device started successfully! \u2705\n\n[IOPROC] called #0: inBuffers=0 inBytes=0 outBuffers=1 \u274c\n[IOPROC] called #100: inBuffers=0 inBytes=0 outBuffers=1 \u274c\n[IOPROC] called #200: inBuffers=0 inBytes=0 outBuffers=1 \u274c\n\nRead 0 bytes \u274c\n</code></pre></p> <p>Analysis: - All CoreAudio APIs return <code>noErr</code> (success) - Tap and Aggregate Device created successfully - IOProc invoked but receives NO input buffers - Aggregate Device approach is architecturally wrong</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#4-c-extension-refactored-direct-tap","title":"4. C Extension (Refactored, Direct Tap)","text":"<p>Status: Correct architecture, blocked by API unavailability</p> <p>Test Results: <pre><code>[DEBUG] create_process_tap: Starting...\n[DEBUG] Converting PIDs to AudioObjectIDs...\nPython error: Failed to create process tap:\n</code></pre></p> <p>Analysis: - Code is architecturally correct (matches PyObjC approach) - PID\u2192AudioObjectID translation fails - <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> API unavailable</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#timeline-analysis","title":"Timeline Analysis","text":"Date Commit Event Status 2025-11-17 ef3cc65 PyObjC prototype created \"Phase 1 - Prototype\" 2025-11-17 8d78147 Linux PipeWire work merged Swift CLI present but not tested 2025-11-18 d1f53b0 Merge from main \"Testing Pending\" in docs 2025-11-18 d79b26a PyObjC marked \"Official\" \"Verified Working\" (unverified) 2025-11-18 Current Investigation All implementations fail"},{"location":"experimental/c_extension_investigation/CONCLUSION/#critical-questions","title":"Critical Questions","text":""},{"location":"experimental/c_extension_investigation/CONCLUSION/#q1-was-it-ever-actually-working","title":"Q1: Was it ever actually working?","text":"<p>Answer: Probably not.</p> <p>Evidence: 1. Documentation explicitly states \"Testing Requirements (Pending)\" 2. Swift CLI code doesn't compile on current SDK 3. No test logs or output demonstrating successful audio capture 4. All implementations depend on unavailable API</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#q2-why-was-it-marked-verified-working","title":"Q2: Why was it marked \"Verified Working\"?","text":"<p>Hypothesis: 1. Optimistic assumption based on API documentation 2. Testing was planned but never executed 3. Confusion between \"compiles/runs\" vs \"actually captures audio\" 4. Process discovery working \u2260 audio capture working</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#q3-did-sdk-definitions-change","title":"Q3: Did SDK definitions change?","text":"<p>Answer: Almost certainly yes.</p> <p>Evidence: - <code>CATapDescription</code> structure members don't match code expectations - <code>kAudioTapProcessingTypeMixDown</code> constant doesn't exist - <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> unavailable</p> <p>Apple may have: 1. Changed API definitions between macOS versions 2. Never publicly released these APIs 3. Deprecated the APIs after initial documentation</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#technical-analysis","title":"Technical Analysis","text":""},{"location":"experimental/c_extension_investigation/CONCLUSION/#api-availability-matrix","title":"API Availability Matrix","text":"API Expected Actual Status <code>AudioHardwareCreateProcessTap</code> Available (14.4+) Returns noErr, tapID=0 (Swift) \u26a0\ufe0f Partial <code>CATapDescription.mIncludeProcesses</code> Structure member Does not exist \u274c Missing <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> Property selector Not available \u274c Missing <code>kAudioTapProcessingTypeMixDown</code> Constant Does not exist \u274c Missing"},{"location":"experimental/c_extension_investigation/CONCLUSION/#architecture-comparison","title":"Architecture Comparison","text":"<p>Wrong Approach (Swift CLI, Old C Extension): <pre><code>Process \u2192 PID\u2192AudioObjectID \u2192 ProcessTap \u2192 AggregateDevice \u2192 IOProc\n                                                    \u2193\n                                        No input streams! (0 bytes)\n</code></pre></p> <p>Correct Approach (PyObjC, Refactored C Extension): <pre><code>Process \u2192 PID\u2192AudioObjectID \u2192 ProcessTap \u2192 IOProc (direct)\n             \u2193\n      API unavailable! (blocked)\n</code></pre></p> <p>Both approaches fail, but for different reasons.</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#system-environment","title":"System Environment","text":"<ul> <li>macOS Version: 14.6 (Darwin 24.6.0)</li> <li>Architecture: arm64 (Apple Silicon)</li> <li>Xcode/SDK: Current (as of 2025-11-18)</li> <li>Expected Requirement: macOS 14.4+ (Sonoma)</li> </ul>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#conclusion","title":"Conclusion","text":""},{"location":"experimental/c_extension_investigation/CONCLUSION/#primary-findings","title":"Primary Findings","text":"<ol> <li>Process Tap API is not functional on macOS 14.6</li> <li>Critical APIs unavailable or incomplete</li> <li> <p>SDK definitions incompatible with documentation</p> </li> <li> <p>No implementation was ever verified working</p> </li> <li>\"Verified Working\" status was premature</li> <li> <p>No test logs or evidence of successful capture</p> </li> <li> <p>All three approaches fail:</p> </li> <li>Swift CLI: Doesn't compile</li> <li>PyObjC: API unavailable</li> <li>C Extension: 0 bytes (Aggregate) or API unavailable (Direct)</li> </ol>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#recommendations","title":"Recommendations","text":"<p>\u274c DO NOT pursue Process Tap API approach</p> <p>\u2705 Viable Alternatives:</p> <ol> <li>BlackHole + Multi-Output Device</li> <li>Proven, stable, works on all macOS versions</li> <li>Requires manual audio routing setup</li> <li> <p>Not truly per-process (system-wide routing)</p> </li> <li> <p>Screen Capture Kit (SCK) Audio API (macOS 13+)</p> </li> <li>Official Apple API for process-specific capture</li> <li>Designed for screen recording but includes audio</li> <li>Requires app permissions</li> <li> <p>Reference: https://developer.apple.com/documentation/screencapturekit</p> </li> <li> <p>AudioServerPlugin</p> </li> <li>Low-level Core Audio plugin</li> <li>Can intercept audio at HAL level</li> <li> <p>Complex implementation, requires code signing</p> </li> <li> <p>Virtual Audio Devices</p> </li> <li>Use Multi-Output Device + process-specific routing</li> <li>Similar to BlackHole but more automated</li> <li>Still not true per-process isolation</li> </ol>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#best-option-screen-capture-kit","title":"Best Option: Screen Capture Kit","text":"<p>Recommendation: Implement Screen Capture Kit Audio backend</p> <p>Advantages: - Official Apple API (macOS 13+) - Designed for per-process capture - Well-documented and supported - No undocumented APIs or hacks</p> <p>Implementation Approach: <pre><code>import ScreenCaptureKit\n\n// 1. Get available content\nlet content = try await SCShareableContent.current\n\n// 2. Filter for target process\nlet targetApp = content.applications.first { $0.processID == targetPID }\n\n// 3. Create stream configuration\nlet config = SCStreamConfiguration()\nconfig.capturesAudio = true\nconfig.sampleRate = 48000\nconfig.channelCount = 2\n\n// 4. Create and start stream\nlet filter = SCContentFilter(desktopIndependentWindow: targetApp.mainWindow!)\nlet stream = SCStream(filter: filter, configuration: config, delegate: self)\ntry stream.addStreamOutput(self, type: .audio, sampleHandlerQueue: audioQueue)\ntry await stream.startCapture()\n</code></pre></p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#archive-purpose","title":"Archive Purpose","text":"<p>This investigation is archived in <code>docs/experimental/c_extension_investigation/</code> as: - Historical record of Process Tap API investigation - Reference for future macOS audio capture work - Evidence that Process Tap API is not viable on macOS 14.6 - Lesson learned: Always verify API availability before claiming \"Verified Working\"</p>"},{"location":"experimental/c_extension_investigation/CONCLUSION/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Archive investigation (completed)</li> <li>\u23ed\ufe0f Research Screen Capture Kit Audio implementation</li> <li>\u23ed\ufe0f Prototype SCK backend for ProcTap</li> <li>\u23ed\ufe0f Update documentation to reflect SCK as official macOS backend</li> <li>\u23ed\ufe0f Mark Process Tap approaches as experimental/deprecated</li> </ol> <p>Date: 2025-11-18 Investigator: Claude Code + m96-chan System: macOS 14.6 (Darwin 24.6.0), arm64</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/","title":"ProcTap macOS C Extension Debug Log","text":""},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#test-execution-2025-11-18-043313","title":"Test Execution: 2025-11-18 04:33:13","text":""},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#process-information","title":"Process Information","text":"<ul> <li>Target PID: 22578 (say command)</li> <li>Command: \"This is a longer test message to ensure audio is playing during capture\"</li> </ul>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-1-process-tap-creation","title":"Phase 1: Process Tap Creation \u2705","text":"<p><pre><code>[DEBUG] create_process_tap: Starting...\n[DEBUG] create_process_tap: Creating CATapDescription...\n[DEBUG] create_process_tap: Got tap UUID from description: 7B42E589-8E83-4365-B7EE-9C6D2DC1BE85\n[DEBUG] create_process_tap: Calling AudioHardwareCreateProcessTap...\n[DEBUG] create_process_tap: Process tap created with ID: 118 \u2705\n</code></pre> Status: SUCCESS - Valid tap ID (not 0)</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-2-default-device-detection","title":"Phase 2: Default Device Detection \u2705","text":"<p><pre><code>[DEBUG] Getting default output device UID...\n[DEBUG] Got device UID: BuiltInSpeakerDevice\n</code></pre> Status: SUCCESS</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-3-aggregate-device-configuration","title":"Phase 3: Aggregate Device Configuration \u2705","text":"<pre><code>[DEBUG] create_process_tap: Creating aggregate device...\n[DEBUG] Generating aggregate UUID...\n[DEBUG] Aggregate UUID: FF3B4E41-05A4-4023-9508-AC02E604D9D3\n</code></pre>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#sub-device-dictionary","title":"Sub-device Dictionary:","text":"<pre><code>{\n    \"uid\": \"BuiltInSpeakerDevice\"\n}\n</code></pre>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#tap-dictionary","title":"Tap Dictionary:","text":"<pre><code>{\n    \"drift\": 1,\n    \"uid\": \"7B42E589-8E83-4365-B7EE-9C6D2DC1BE85\"\n}\n</code></pre>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#main-device-dictionary","title":"Main Device Dictionary:","text":"<pre><code>{\n    \"TapAutoStart\": 1,\n    \"TapList\": [\n        {\n            \"drift\": 1,\n            \"uid\": \"7B42E589-8E83-4365-B7EE-9C6D2DC1BE85\"\n        }\n    ],\n    \"master\": \"BuiltInSpeakerDevice\",\n    \"name\": \"ProcTap Aggregate\",\n    \"private\": 1,\n    \"stacked\": 0,\n    \"subdevices\": [\n        {\n            \"uid\": \"BuiltInSpeakerDevice\"\n        }\n    ],\n    \"uid\": \"FF3B4E41-05A4-4023-9508-AC02E604D9D3\"\n}\n</code></pre>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-4-aggregate-device-creation","title":"Phase 4: Aggregate Device Creation \u2705","text":"<p><pre><code>[DEBUG] Calling AudioHardwareCreateAggregateDevice...\n[DEBUG] create_process_tap: AudioHardwareCreateAggregateDevice returned: 0, device_id: 119\n</code></pre> Status: SUCCESS - OSStatus = 0 (noErr), Device ID = 119</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-5-device-initialization","title":"Phase 5: Device Initialization \u2705","text":"<pre><code>Wait time: 500ms\n[DEBUG] create_process_tap: Aggregate device created successfully!\n</code></pre>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-6-ioproc-setup","title":"Phase 6: IOProc Setup \u2705","text":"<p><pre><code>[DEBUG] IOProcID created for aggregate device 119\n[DEBUG] Aggregate device started successfully!\n</code></pre> Status: SUCCESS - AudioDeviceStart returned noErr</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-7-audio-capture","title":"Phase 7: Audio Capture \u274c","text":"<p><pre><code>Read 0 bytes\nRead 0 bytes\nRead 0 bytes\nRead 0 bytes\nRead 0 bytes\n</code></pre> Status: FAILURE - No audio data received</p> <p>Possible Causes: 1. IOProc callback not being invoked by CoreAudio 2. Input stream not configured on aggregate device 3. Stream format mismatch between tap and callback 4. Process Tap not producing data (process audio output issue)</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#phase-8-cleanup","title":"Phase 8: Cleanup \u2705","text":"<p><pre><code>[DEBUG] Aggregate device stopped\n[DEBUG] Aggregate device destroyed\n[DEBUG] Process tap destroyed\n</code></pre> Status: SUCCESS</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#summary","title":"Summary","text":""},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#working-components","title":"Working Components \u2705","text":"<ul> <li> Process Tap creation (tap ID: 118)</li> <li> UUID retrieval via KVC</li> <li> Aggregate Device creation (device ID: 119)</li> <li> IOProcID registration</li> <li> Device start/stop lifecycle</li> <li> Resource cleanup</li> </ul>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#not-working","title":"Not Working \u274c","text":"<ul> <li> Audio data flow through IOProc callback</li> <li> Ring buffer receiving data</li> </ul>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#comparison-swift-cli-vs-c-extension","title":"Comparison: Swift CLI vs C Extension","text":"Feature Swift CLI C Extension Process Tap \u274c tapID=0 (global mode) \u2705 tapID=118 (PID mode) Aggregate Device N/A \u2705 device_id=119 IOProc N/A \u2705 Registered Data Capture \u274c Failed early \u274c 0 bytes <p>Key Finding: C extension successfully creates all devices but IOProc receives no data.</p>"},{"location":"experimental/c_extension_investigation/DEBUG_LOG/#next-steps","title":"Next Steps","text":"<ol> <li>Add IOProc Callback Logging</li> <li>Verify if callback is being invoked</li> <li>Check <code>inInputData</code> buffer status</li> <li> <p>Log buffer sizes and format</p> </li> <li> <p>Configure Input Stream Format</p> </li> <li>Set <code>kAudioDevicePropertyStreamFormat</code> on input scope</li> <li> <p>Match format: 16kHz, 1ch, 16-bit PCM</p> </li> <li> <p>Verify Tap Data Flow</p> </li> <li>Check if Process Tap is producing audio</li> <li>Query tap device properties</li> <li> <p>Test with different audio sources</p> </li> <li> <p>Compare with Swift Implementation</p> </li> <li>Review Swift's <code>configureDeviceFormat()</code></li> <li>Check for missing setup steps</li> </ol>"},{"location":"experimental/c_extension_investigation/FINDINGS/","title":"macOS Process Tap Implementation Findings","text":""},{"location":"experimental/c_extension_investigation/FINDINGS/#date-2025-11-18","title":"Date: 2025-11-18","text":""},{"location":"experimental/c_extension_investigation/FINDINGS/#summary","title":"Summary","text":"<p>Investigation revealed that all three macOS backends are non-functional, but the root cause has been identified.</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#test-results","title":"Test Results","text":""},{"location":"experimental/c_extension_investigation/FINDINGS/#1-c-extension-srcproctap_native_macosm-incorrect-architecture","title":"1. C Extension (<code>src/proctap/_native_macos.m</code>) - INCORRECT ARCHITECTURE","text":"<p>Status: Creates tap successfully but receives 0 bytes</p> <p>What Works: - \u2705 Process Tap creation (tapID = 118, non-zero) - \u2705 Tap ASBD retrieval (44100 Hz, 2ch, 32-bit) - \u2705 Aggregate Device creation (device_id = 120) - \u2705 IOProc registration and invocation</p> <p>What Fails: - \u274c IOProc receives <code>inBuffers=0, outBuffers=1</code> (no input streams) - \u274c 0 bytes captured despite all APIs returning noErr</p> <p>Root Cause: WRONG ARCHITECTURE - The implementation creates an Aggregate Device and attaches IOProc to it, but: - Aggregate devices don't automatically create input streams from Process Taps - The IOProc is being called for OUTPUT rendering, not INPUT capture - Setting input stream format fails with error <code>2003332927</code></p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#2-swift-cli-swiftproctap-macossourcesmainswift-tap-creation-fails","title":"2. Swift CLI (<code>swift/proctap-macos/Sources/main.swift</code>) - TAP CREATION FAILS","text":"<p>Status: Cannot create tap</p> <p>Error: <code>AudioHardwareCreateProcessTap</code> returns <code>noErr</code> (status=0) but <code>tapID=0</code> (invalid)</p> <p>Implications: Same aggregate device approach as C extension, would fail even if tap creation succeeded</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#3-pyobjc-backend-srcproctapbackendsmacos_pyobjcpy-api-unavailable","title":"3. PyObjC Backend (<code>src/proctap/backends/macos_pyobjc.py</code>) - API UNAVAILABLE","text":"<p>Status: Marked as \"Verified Working\" but actually fails</p> <p>Error: <code>kAudioHardwarePropertyTranslatePIDToProcessObject not available</code></p> <p>However: Code architecture reveals the CORRECT approach!</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#the-correct-approach-from-pyobjc-architecture","title":"THE CORRECT APPROACH (from PyObjC Architecture)","text":"<p>The PyObjC backend code (even though not working) shows the proper architecture:</p> <pre><code># Step 1: Create Process Tap\ntap_device_id = create_process_tap(process_object_id, kCATapTypeOutput)\n\n# Step 2: Attach IOProc DIRECTLY to tap device (NOT aggregate!)\nstatus = AudioDeviceCreateIOProcID(\n    tap_device_id,  # \u2190 Process Tap ID directly!\n    io_callback,\n    None,\n    &amp;io_proc_id\n)\n\n# Step 3: Start tap device directly\nstatus = AudioDeviceStart(tap_device_id, io_proc_id)\n</code></pre> <p>Key Insight: NO AGGREGATE DEVICE NEEDED!</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#why-c-extension-is-wrong","title":"Why C Extension is Wrong","text":"<p>Current C extension flow: <pre><code>Process Tap \u2192 Aggregate Device \u2192 IOProc\n    \u2193              \u2193\n   tapID      device_id = 120\n  (118)\n</code></pre></p> <p>Correct flow should be: <pre><code>Process Tap \u2192 IOProc (directly)\n    \u2193\n   tapID\n  (118)\n</code></pre></p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#evidence-from-ioproc-logs","title":"Evidence from IOProc Logs","text":"<pre><code>[IOPROC] called #0: inBuffers=0 inBytes=0 outBuffers=1\n[IOPROC] called #100: inBuffers=0 inBytes=0 outBuffers=1\n[IOPROC] called #200: inBuffers=0 inBytes=0 outBuffers=1\n</code></pre> <ul> <li><code>inBuffers=0</code>: No input streams on aggregate device</li> <li><code>outBuffers=1</code>: IOProc is being called for OUTPUT rendering (playing to speakers)</li> <li>The tap data has nowhere to go because the aggregate device has no input path</li> </ul>"},{"location":"experimental/c_extension_investigation/FINDINGS/#required-c-extension-modifications","title":"Required C Extension Modifications","text":""},{"location":"experimental/c_extension_investigation/FINDINGS/#changes-needed-in-srcproctap_native_macosm","title":"Changes Needed in <code>src/proctap/_native_macos.m</code>:","text":"<ol> <li>REMOVE all aggregate device code:</li> <li>Remove <code>AudioHardwareCreateAggregateDevice()</code> call</li> <li>Remove aggregate device dictionary creation</li> <li>Remove <code>state-&gt;device_id</code> field</li> <li> <p>Remove aggregate device cleanup</p> </li> <li> <p>CHANGE IOProc attachment target:    <pre><code>// OLD (wrong):\nAudioDeviceCreateIOProcID(\n    state-&gt;device_id,  // Aggregate device\n    ...\n)\n\n// NEW (correct):\nAudioDeviceCreateIOProcID(\n    state-&gt;tap_id,     // Process Tap directly!\n    ...\n)\n</code></pre></p> </li> <li> <p>CHANGE device start target:    <pre><code>// OLD (wrong):\nAudioDeviceStart(state-&gt;device_id, proc_id)\n\n// NEW (correct):\nAudioDeviceStart(state-&gt;tap_id, proc_id)\n</code></pre></p> </li> <li> <p>SIMPLIFY ProcessTapState structure:    <pre><code>typedef struct {\n    AudioObjectID tap_id;          // Process Tap ID\n    AudioDeviceIOProcID io_proc_id; // IOProc ID\n    // REMOVE: AudioDeviceID device_id;\n    // Keep other fields...\n} ProcessTapState;\n</code></pre></p> </li> </ol>"},{"location":"experimental/c_extension_investigation/FINDINGS/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>Create backup of current <code>_native_macos.m</code></li> <li>Remove ~300 lines of aggregate device code</li> <li>Modify IOProc attachment to use <code>state-&gt;tap_id</code></li> <li>Modify device start/stop to use <code>state-&gt;tap_id</code></li> <li>Test with <code>say</code> command</li> <li>Verify IOProc receives input buffers: <code>inBuffers &gt; 0</code></li> </ol>"},{"location":"experimental/c_extension_investigation/FINDINGS/#expected-outcome-after-fix","title":"Expected Outcome After Fix","text":"<p>After implementing the correct architecture, IOProc logs should show: <pre><code>[IOPROC] called #0: inBuffers=1 inBytes=XXXX outBuffers=0\n</code></pre></p> <p>And <code>read_tap()</code> should return non-zero bytes.</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#api-compatibility-notes","title":"API Compatibility Notes","text":"<ul> <li>Process Tap API requires macOS 14.4+ (Sonoma)</li> <li><code>AudioHardwareCreateProcessTap</code> introduced in macOS 14.4</li> <li><code>CATapDescription</code> class available in CoreAudio framework</li> <li>No special entitlements needed beyond audio input permission</li> </ul>"},{"location":"experimental/c_extension_investigation/FINDINGS/#references","title":"References","text":"<ul> <li>Apple Core Audio documentation (sparse on Process Tap)</li> <li>PyObjC backend architecture (correct approach, non-working implementation)</li> <li>DEBUG_LOG.md (detailed test logs showing aggregate device approach failing)</li> </ul>"},{"location":"experimental/c_extension_investigation/FINDINGS/#update-final-investigation-results-2025-11-18-0508","title":"UPDATE: Final Investigation Results (2025-11-18 05:08)","text":""},{"location":"experimental/c_extension_investigation/FINDINGS/#refactoring-completed-successfully","title":"Refactoring Completed Successfully","text":"<p>Architectural changes implemented: 1. \u2705 Removed all Aggregate Device code (~300 lines deleted) 2. \u2705 Changed IOProc attachment from <code>device_id</code> \u2192 <code>tap_id</code> (direct) 3. \u2705 Simplified ProcessTapState structure (removed <code>device_id</code> field) 4. \u2705 Updated start/stop/destroy to use <code>tap_id</code> only</p> <p>Code now matches PyObjC architecture: <pre><code>Process Tap (tap_id) \u2192 IOProc (direct) \u2192 Ring Buffer \u2192 Python\n</code></pre></p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#critical-bug-fixed-pid-vs-audioobjectid","title":"Critical Bug Fixed: PID vs AudioObjectID","text":"<p>Problem Found: - CATapDescription expects AudioObjectID (Process Object ID) - Previous refactoring passed PID directly \u2192 caused <code>tapID=0</code> error</p> <p>Solution Implemented: 1. Added constant: <code>kAudioHardwarePropertyTranslatePIDToProcessObject = 0x70696432</code> 2. Added function: <code>translate_pid_to_process_object(pid, *out_object_id)</code> 3. Modified <code>create_process_tap()</code> to:    - Convert PIDs \u2192 AudioObjectIDs before CATapDescription creation    - Pass AudioObjectIDs to <code>initMonoMixdownOfProcesses:</code> / <code>initStereoMixdownOfProcesses:</code>    - Free allocated arrays after use</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#final-blocker-api-unavailable","title":"FINAL BLOCKER: API Unavailable","text":"<p>Test Results: <pre><code>[DEBUG] create_process_tap: Starting...\n[DEBUG] Converting PIDs to AudioObjectIDs...\nPython error: Failed to create process tap:\n</code></pre></p> <p>Analysis: - No <code>[DEBUG] PID X \u2192 AudioObjectID Y</code> log appears - <code>translate_pid_to_process_object()</code> fails on first call - <code>AudioObjectGetPropertyData</code> with <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> returns error</p> <p>Root Cause: The <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> API is NOT AVAILABLE on this macOS version.</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#verification-across-all-implementations","title":"Verification Across All Implementations","text":"Implementation Status Error Swift CLI \u274c Fails <code>tapID=0</code> (API returns success but invalid ID) C Extension \u274c Fails PID\u2192AudioObjectID translation fails PyObjC Backend \u274c Fails \"kAudioHardwarePropertyTranslatePIDToProcessObject not available\" <p>All three implementations fail at the same API call.</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#system-information","title":"System Information","text":"<ul> <li>macOS Version: 14.6 (Darwin 24.6.0)</li> <li>Architecture: arm64 (Apple Silicon)</li> <li>Expected API Availability: macOS 14.4+ (Sonoma)</li> </ul>"},{"location":"experimental/c_extension_investigation/FINDINGS/#conclusion","title":"Conclusion","text":"<p>The Core Audio Process Tap API does not function on this system, despite: - Being within the documented version requirement (14.4+) - All setup code being correct - Multiple implementation approaches attempted</p> <p>Possible Explanations: 1. Apple removed/disabled this API in macOS 14.6 2. API requires undocumented permissions or entitlements 3. API was experimental and has been deprecated 4. System-specific issue (SIP, privacy settings, etc.)</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#recommended-actions","title":"Recommended Actions","text":"<p>\u274c Do NOT continue with Process Tap API approach</p> <p>\u2705 Alternative Solutions: 1. BlackHole + Loopback Audio - Proven, reliable, works on all macOS versions 2. Screen Capture Kit Audio (macOS 13+) - Official API with process isolation 3. AudioServerPlugin - Low-level but complex 4. Virtual Audio Devices - Redirect per-process via Multi-Output Device</p>"},{"location":"experimental/c_extension_investigation/FINDINGS/#code-status","title":"Code Status","text":"<ul> <li>Refactored C extension: Architecturally Correct \u2705</li> <li>PID\u2192AudioObjectID fix: Implemented Correctly \u2705</li> <li>Functionality: Blocked by macOS API unavailability \u274c</li> </ul> <p>Files Modified: - <code>src/proctap/_native_macos.m</code> - Refactored, compiles successfully - Architecture changed from Aggregate Device to direct Tap attachment - Memory management corrected (all malloc/free balanced)</p> <p>The implementation is correct, but the underlying macOS API does not work.</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/","title":"macOS Backend Version Comparison","text":""},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#timeline-and-architecture-analysis","title":"Timeline and Architecture Analysis","text":""},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#commit-8d78147-2025-11-17-swift-cli-backend","title":"Commit 8d78147 (2025-11-17) - Swift CLI Backend","text":"<p>File: <code>src/proctap/backends/macos.py</code> (Swift helper subprocess) Swift: <code>swift/proctap-macos/Sources/main.swift</code></p> <p>Architecture: <pre><code>PID \u2192 AudioObjectID (via kAudioHardwarePropertyTranslatePIDToProcessObject)\n  \u2193\nProcess Tap Creation\n  \u2193\nAggregate Device Creation (with tap)\n  \u2193\nIOProc Attachment (to aggregate device)\n  \u2193\nAudio Capture\n</code></pre></p> <p>Key Code (Swift): <pre><code>// Line 135-145: PID \u2192 ProcessObject translation\nlet status = AudioObjectGetPropertyData(\n    AudioObjectID(kAudioObjectSystemObject),\n    &amp;AudioObjectPropertyAddress(\n        mSelector: kAudioHardwarePropertyTranslatePIDToProcessObject,\n        ...\n    ),\n    ...\n    &amp;processObject\n)\n\n// Line 95-96: Aggregate Device approach\ndevice = try createAggregateDevice(with: tap)\n</code></pre></p> <p>Status: \"Implemented for macOS 14.4+\"</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#commit-ef3cc65-2025-11-17-pyobjc-prototype","title":"Commit ef3cc65 (2025-11-17) - PyObjC Prototype","text":"<p>File: <code>src/proctap/backends/macos_pyobjc.py</code> (initial prototype)</p> <p>Architecture: Phase 1 - Process Discovery Only - Only implemented PID \u2192 AudioObjectID translation - No actual audio capture implemented yet</p> <p>Status: \"Phase 1 - Prototype Implementation\"</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#commit-d79b26a-2025-11-18-pyobjc-official-backend","title":"Commit d79b26a (2025-11-18) - PyObjC Official Backend","text":"<p>File: <code>src/proctap/backends/macos_pyobjc.py</code> (full implementation)</p> <p>Architecture: <pre><code>PID \u2192 AudioObjectID (via kAudioHardwarePropertyTranslatePIDToProcessObject)\n  \u2193\nProcess Tap Creation (CATapDescription with AudioObjectID)\n  \u2193\nIOProc Attachment (DIRECTLY to tap_device_id, NO aggregate device!)\n  \u2193\nAudio Capture\n</code></pre></p> <p>Key Code (Python/ctypes): <pre><code># Line 454-488: PID \u2192 ProcessObject translation\nstatus = _AudioObjectGetPropertyData(\n    kAudioObjectSystemObject,\n    byref(address),  # kAudioHardwarePropertyTranslatePIDToProcessObject\n    ...\n    byref(process_object_id)\n)\n\n# Line 636-657: Direct tap attachment (NO aggregate device!)\nself._tap_device_id = create_process_tap(self._process_object_id, ...)\nstatus = _AudioDeviceCreateIOProcID(\n    self._tap_device_id,  # Direct to tap!\n    self._io_callback,\n    ...\n)\nstatus = _AudioDeviceStart(self._tap_device_id, ...)\n</code></pre></p> <p>Status: \"Phase 3 - Official macOS Backend (Verified Working)\" - \u26a0\ufe0f This \"Verified Working\" claim is questionable - No test logs or evidence of actual audio capture</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#current-investigation-2025-11-18-c-extension-refactoring","title":"Current Investigation (2025-11-18) - C Extension Refactoring","text":"<p>Original C Extension (Aggregate Device approach): - File: <code>src/proctap/experimental/_native_macos.m</code> (at d79b26a) - Used Aggregate Device (same as Swift CLI) - Test Results:   - \u2705 Tap ID: 118 created   - \u2705 Aggregate Device ID: 120 created   - \u2705 IOProc invoked   - \u274c <code>inBuffers=0, outBuffers=1</code> (no input streams)   - \u274c 0 bytes captured</p> <p>Refactored C Extension (Direct tap approach): - File: <code>src/proctap/_native_macos.m</code> (refactored, not committed) - Removed Aggregate Device - Attached IOProc directly to tap (same architecture as PyObjC) - Test Results:   - \u274c PID\u2192AudioObjectID translation fails   - \u274c <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> API unavailable</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#api-availability-analysis","title":"API Availability Analysis","text":""},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#kaudiohardwarepropertytranslatepidtoprocessobject-pid2","title":"<code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> ('pid2')","text":"<p>Used by: - Swift CLI (8d78147) - PyObjC Backend (d79b26a) - C Extension (all versions)</p> <p>Test Results on macOS 14.6 (Darwin 24.6.0): | Implementation | API Call Result | Notes | |----------------|-----------------|-------| | Swift CLI | Returns <code>noErr</code> but <code>tapID=0</code> | Invalid tap created | | PyObjC | <code>AudioObjectHasProperty</code> returns False | Property not available | | C Extension (refactored) | Translation fails, returns error | Same as PyObjC | | C Extension (Aggregate) | Successfully created tap/device but 0 bytes | API worked but capture failed |</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#discrepancy","title":"Discrepancy","text":"<p>Critical Question: Why does the C Extension with Aggregate Device successfully create tap (tapID=118) but the refactored version fails at PID\u2192AudioObjectID translation?</p> <p>Hypothesis: 1. The Aggregate Device version might be using cached/old compiled binary 2. The Swift CLI binary might be pre-compiled from a different macOS version 3. The API might be intermittently available or require specific conditions</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#aggregate-device-approach-swift-cli-old-c-extension","title":"Aggregate Device Approach (Swift CLI, Old C Extension)","text":"<pre><code>Process \u2192 kAudioHardwarePropertyTranslatePIDToProcessObject \u2192 AudioObjectID\n          \u2193\n       CATapDescription(AudioObjectID) \u2192 AudioHardwareCreateProcessTap\n          \u2193\n       Create Aggregate Device (with tap UUID)\n          \u2193\n       AudioDeviceCreateIOProcID(aggregate_device_id)\n          \u2193\n       AudioDeviceStart(aggregate_device_id)\n          \u2193\n       IOProc receives: inBuffers=0, outBuffers=1 \u274c\n</code></pre> <p>Problem: Aggregate device has no input streams from tap</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#direct-tap-approach-pyobjc-refactored-c-extension","title":"Direct Tap Approach (PyObjC, Refactored C Extension)","text":"<pre><code>Process \u2192 kAudioHardwarePropertyTranslatePIDToProcessObject \u2192 AudioObjectID \u274c\n          \u2193\n       (BLOCKED - API unavailable)\n</code></pre> <p>Problem: Cannot translate PID to AudioObjectID</p>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#conclusion","title":"Conclusion","text":""},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#all-three-implementations-use-the-same-broken-approach","title":"All Three Implementations Use the Same Broken Approach","text":"<ol> <li>Swift CLI (8d78147):</li> <li>Uses <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> \u2705 (somehow works?)</li> <li>Uses Aggregate Device \u274c (wrong architecture)</li> <li> <p>Result: Unknown (needs testing at that commit)</p> </li> <li> <p>PyObjC (d79b26a):</p> </li> <li>Uses <code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> \u274c (API unavailable)</li> <li>Uses Direct Tap Attachment \u2705 (correct architecture)</li> <li> <p>Result: Fails at PID translation</p> </li> <li> <p>C Extension (current):</p> </li> <li>Original: Uses Aggregate Device, gets 0 bytes</li> <li>Refactored: Fails at PID translation</li> </ol>"},{"location":"experimental/c_extension_investigation/VERSION_COMPARISON/#recommendation","title":"Recommendation","text":"<p>Test commit 8d78147 Swift CLI to determine: 1. Does it actually capture audio? 2. If yes, what's different about that environment/build? 3. If no, was it ever actually verified working?</p> <p>Alternative: The entire Process Tap API approach may be fundamentally unavailable on this macOS version (14.6), despite Apple's documentation claiming 14.4+ support.</p>"},{"location":"experimental/c_extension_investigation/fix_summary/","title":"macOS C Extension Fix Summary","text":""},{"location":"experimental/c_extension_investigation/fix_summary/#problem-found","title":"Problem Found","text":"<p><code>tapID=0</code> \u306e\u539f\u56e0: CATapDescription \u306b PID \u3092\u6e21\u3057\u3066\u3044\u305f\u304c\u3001AudioObjectID \u3092\u671f\u5f85\u3057\u3066\u3044\u305f</p>"},{"location":"experimental/c_extension_investigation/fix_summary/#solution","title":"Solution","text":"<ol> <li><code>kAudioHardwarePropertyTranslatePIDToProcessObject</code> \u5b9a\u6570\u3092\u8ffd\u52a0</li> <li><code>translate_pid_to_process_object()</code> \u95a2\u6570\u3092\u5fa9\u5143  </li> <li><code>create_process_tap()</code> \u3067 PID \u2192 AudioObjectID \u5909\u63db\u3092\u5b9f\u884c</li> </ol>"},{"location":"experimental/c_extension_investigation/fix_summary/#code-changes-required","title":"Code Changes Required","text":""},{"location":"experimental/c_extension_investigation/fix_summary/#1-add-constant-after-line-52","title":"1. Add constant (after line 52):","text":"<pre><code>// Property selectors\n#define kAudioHardwarePropertyTranslatePIDToProcessObject 0x70696432  // 'pid2'\n</code></pre>"},{"location":"experimental/c_extension_investigation/fix_summary/#2-add-function-after-get_default_output_device_uid","title":"2. Add function (after get_default_output_device_uid):","text":"<pre><code>/**\n * Translate PID to Process Object ID\n */\nstatic OSStatus translate_pid_to_process_object(pid_t pid, AudioObjectID* out_object_id) {\n    AudioObjectPropertyAddress address = {\n        .mSelector = kAudioHardwarePropertyTranslatePIDToProcessObject,\n        .mScope = kAudioObjectPropertyScopeGlobal,\n        .mElement = kAudioObjectPropertyElementMain\n    };\n\n    UInt32 translation_value = (UInt32)pid;\n    AudioObjectID process_object_id = 0;\n    UInt32 data_size = sizeof(AudioObjectID);\n\n    OSStatus status = AudioObjectGetPropertyData(\n        kAudioObjectSystemObject,\n        &amp;address,\n        sizeof(translation_value),\n        &amp;translation_value,\n        &amp;data_size,\n        &amp;process_object_id\n    );\n\n    if (status == noErr &amp;&amp; out_object_id) {\n        *out_object_id = process_object_id;\n    }\n\n    return status;\n}\n</code></pre>"},{"location":"experimental/c_extension_investigation/fix_summary/#3-modify-create_process_tap-add-pid-audioobjectid-conversion","title":"3. Modify create_process_tap (add PID \u2192 AudioObjectID conversion):","text":"<p>Before CATapDescription creation, add: <pre><code>// Convert PIDs to AudioObjectIDs\nAudioObjectID* include_objects = NULL;\nAudioObjectID* exclude_objects = NULL;\n\nif (state-&gt;include_count &gt; 0) {\n    include_objects = (AudioObjectID*)malloc(sizeof(AudioObjectID) * state-&gt;include_count);\n    for (size_t i = 0; i &lt; state-&gt;include_count; i++) {\n        OSStatus status = translate_pid_to_process_object(state-&gt;include_pids[i], &amp;include_objects[i]);\n        if (status != noErr) {\n            snprintf(state-&gt;error_message, sizeof(state-&gt;error_message),\n                    \"Failed to translate PID %d to AudioObjectID\", state-&gt;include_pids[i]);\n            free(include_objects);\n            return status;\n        }\n        NSLog(@\"[DEBUG] PID %d \u2192 AudioObjectID %u\", state-&gt;include_pids[i], include_objects[i]);\n    }\n}\n\n// Similar for exclude_pids...\n</code></pre></p> <p>Then use <code>include_objects[i]</code> instead of <code>state-&gt;include_pids[i]</code> in NSArray creation.</p> <p>Don't forget to free <code>include_objects</code> and <code>exclude_objects</code> before returning!</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers installing ProcTap on Windows, Linux, and macOS.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Before installing ProcTap, ensure your system meets the platform-specific requirements:</p>"},{"location":"getting-started/installation/#windows-fully-supported","title":"Windows (Fully Supported)","text":"<ul> <li>Operating System: Windows 10 (20H1 or later) or Windows 11</li> <li>Python Version: 3.10, 3.11, 3.12, or 3.13</li> <li>Administrator Rights: Not required for using ProcTap</li> <li>Build Tools (for source installation): Visual Studio Build Tools + Windows SDK</li> </ul> <p>Windows Version Check</p> <p>To check your Windows version, press Win+R, type <code>winver</code>, and press Enter. You need version 2004 (20H1) or later.</p>"},{"location":"getting-started/installation/#linux-fully-supported","title":"Linux (Fully Supported)","text":"<ul> <li>Operating System: Linux with PulseAudio or PipeWire</li> <li>Python Version: 3.10, 3.11, 3.12, or 3.13</li> <li>System Packages: <code>pulseaudio-utils</code> or <code>pipewire</code> with <code>libpipewire-0.3-dev</code> (optional for native API)</li> <li>Auto-detection: Graceful fallback between backends</li> </ul>"},{"location":"getting-started/installation/#macos-officially-supported-v040","title":"macOS (Officially Supported - v0.4.0+)","text":"<ul> <li>Operating System: macOS 13.0 (Ventura) or later</li> <li>Python Version: 3.10, 3.11, 3.12, or 3.13</li> <li>Backend: ScreenCaptureKit (bundleID-based)</li> <li>Permissions: Screen Recording (automatically prompted)</li> <li>Build Tools: Swift toolchain / Xcode Command Line Tools</li> </ul>"},{"location":"getting-started/installation/#installation-from-pypi","title":"Installation from PyPI","text":"<p>The simplest way to install ProcTap is using pip:</p> <pre><code>pip install proc-tap\n</code></pre> <p>This will install the pre-built wheel for your Python version and platform.</p> <p>Platform-specific dependencies are automatically installed: - Linux: <code>pulsectl</code> library is automatically installed - macOS: <code>pyobjc-core</code> and <code>pyobjc-framework-CoreAudio</code> are automatically installed</p>"},{"location":"getting-started/installation/#linux-system-packages","title":"Linux System Packages","text":"<p>On Linux, you also need to install system packages:</p> <pre><code># Ubuntu/Debian - PulseAudio\nsudo apt-get install pulseaudio-utils\n\n# Ubuntu/Debian - PipeWire (recommended)\nsudo apt-get install pipewire pipewire-media-session\n\n# Optional: Native PipeWire API (ultra-low latency)\nsudo apt-get install libpipewire-0.3-dev\n\n# Fedora/RHEL - PulseAudio\nsudo dnf install pulseaudio-utils\n\n# Fedora/RHEL - PipeWire (recommended)\nsudo dnf install pipewire pipewire-utils\n</code></pre>"},{"location":"getting-started/installation/#macos-build-requirements","title":"macOS Build Requirements","text":"<p>On macOS, you need to build the Swift helper binary:</p> <pre><code># Install Xcode Command Line Tools (if not already installed)\nxcode-select --install\n\n# Build the Swift helper\ncd src/proctap/swift/screencapture-audio\nswift build -c release\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that ProcTap is working:</p> <pre><code>python -c \"from proctap import ProcessAudioCapture; print('\u2713 ProcTap installed successfully')\"\n</code></pre>"},{"location":"getting-started/installation/#installation-from-source","title":"Installation from Source","text":"<p>If you want to build from source or contribute to development:</p>"},{"location":"getting-started/installation/#1-install-build-dependencies","title":"1. Install Build Dependencies","text":""},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ul> <li>Visual Studio Build Tools - Download</li> <li>Windows SDK - Included with Visual Studio Build Tools</li> </ul>"},{"location":"getting-started/installation/#linux","title":"Linux","text":"<ul> <li>Build essentials: <code>sudo apt-get install build-essential</code> (usually pre-installed)</li> <li>PulseAudio development files: <code>sudo apt-get install libpulse-dev</code> (optional)</li> <li>PipeWire development files: <code>sudo apt-get install libpipewire-0.3-dev</code> (optional, for native API)</li> </ul>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<ul> <li>Xcode Command Line Tools: <code>xcode-select --install</code></li> <li>Swift toolchain: Included with Xcode Command Line Tools</li> </ul>"},{"location":"getting-started/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/m96-chan/ProcTap\ncd ProcTap\n</code></pre>"},{"location":"getting-started/installation/#3-install-in-development-mode","title":"3. Install in Development Mode","text":"<pre><code># Basic installation\npip install -e .\n\n# Or with development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#4-build-platform-specific-components","title":"4. Build Platform-Specific Components","text":""},{"location":"getting-started/installation/#macos-build-swift-helper","title":"macOS: Build Swift Helper","text":"<pre><code>cd src/proctap/swift/screencapture-audio\nswift build -c release\ncd ../../../..\n</code></pre>"},{"location":"getting-started/installation/#5-verify-build","title":"5. Verify Build","text":"<pre><code>python -c \"from proctap import ProcessAudioCapture; print('\u2713 Build successful')\"\n</code></pre> <p>Rebuilding After Code Changes</p> <p>Windows: If you modify the C++ code in <code>src/proctap/_native.cpp</code>, rebuild with: <pre><code>pip install -e . --force-reinstall --no-deps\n</code></pre></p> <p>macOS: If you modify the Swift helper, rebuild with: <pre><code>cd src/proctap/swift/screencapture-audio\nswift build -c release\n</code></pre></p>"},{"location":"getting-started/installation/#installation-from-testpypi","title":"Installation from TestPyPI","text":"<p>For testing pre-release versions:</p> <pre><code>pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ proc-tap\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#for-examples","title":"For Examples","text":"<p>Some examples require additional packages:</p> <pre><code># For process name \u2192 PID resolution\npip install psutil\n</code></pre>"},{"location":"getting-started/installation/#for-development","title":"For Development","text":"<p>Development dependencies are specified in <code>pyproject.toml</code>:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This includes: - <code>pytest</code> - Test framework - <code>mypy</code> - Type checking - <code>types-setuptools</code> - Type stubs</p>"},{"location":"getting-started/installation/#for-documentation","title":"For Documentation","text":"<p>To build this documentation locally:</p> <pre><code>pip install mkdocs-material mkdocstrings[python]\nmkdocs serve\n</code></pre> <p>Then open http://localhost:8000.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-error-no-module-named-proctap","title":"Import Error: No module named 'proctap'","text":"<p>Problem: Python can't find the ProcTap package.</p> <p>Solution: <pre><code>pip install proc-tap\n# Or for development:\npip install -e .\n</code></pre></p>"},{"location":"getting-started/installation/#import-error-dll-load-failed","title":"Import Error: DLL load failed","text":"<p>Problem: The C++ extension can't load.</p> <p>Possible causes: 1. Missing Visual C++ Redistributable 2. Incompatible Python version 3. Build failed during installation</p> <p>Solution: <pre><code># Reinstall with verbose output\npip install proc-tap --force-reinstall -v\n</code></pre></p>"},{"location":"getting-started/installation/#build-error-clexe-not-found","title":"Build Error: 'cl.exe' not found","text":"<p>Problem: C++ compiler not found.</p> <p>Solution: Install Visual Studio Build Tools:</p> <ol> <li>Download from Microsoft</li> <li>Run installer</li> <li>Select \"Desktop development with C++\"</li> <li>Include Windows SDK</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Get started with ProcTap</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with ProcTap in just a few minutes!</p>"},{"location":"getting-started/quickstart/#basic-concepts","title":"Basic Concepts","text":"<p>ProcTap captures audio from a specific Windows process using its Process ID (PID). Unlike system-wide recording, this lets you isolate audio from individual applications.</p> <pre><code>graph LR\n    A[Target Process&lt;br/&gt;VRChat.exe] --&gt;|Audio Output| B[WASAPI]\n    B --&gt;|Per-Process&lt;br/&gt;Loopback| C[ProcTap]\n    C --&gt;|PCM Data| D[Your Code]\n\n    E[Other Apps&lt;br/&gt;Discord, Spotify] --&gt;|Ignored| B\n\n    style A fill:#4CAF50\n    style C fill:#2196F3\n    style E fill:#999</code></pre>"},{"location":"getting-started/quickstart/#finding-process-id","title":"Finding Process ID","text":"<p>There are several ways to find a process ID:</p>"},{"location":"getting-started/quickstart/#method-1-task-manager","title":"Method 1: Task Manager","text":"<ol> <li>Press Ctrl+Shift+Esc to open Task Manager</li> <li>Go to the \"Details\" tab</li> <li>Find your process and note the PID column</li> </ol>"},{"location":"getting-started/quickstart/#method-2-command-line","title":"Method 2: Command Line","text":"<pre><code># List all processes\ntasklist\n\n# Search for specific process\ntasklist | findstr \"VRChat\"\n</code></pre>"},{"location":"getting-started/quickstart/#method-3-using-psutil-recommended","title":"Method 3: Using psutil (Recommended)","text":"<pre><code>import psutil\n\ndef find_pid_by_name(name: str) -&gt; int:\n    \"\"\"Find PID by process name.\"\"\"\n    for proc in psutil.process_iter(['pid', 'name']):\n        if proc.info['name'].lower() == name.lower():\n            return proc.info['pid']\n        # Also match without .exe extension\n        if proc.info['name'].lower() == f\"{name.lower()}.exe\":\n            return proc.info['pid']\n    raise ValueError(f\"Process '{name}' not found\")\n\n# Find VRChat process\npid = find_pid_by_name(\"VRChat.exe\")\nprint(f\"VRChat PID: {pid}\")\n</code></pre>"},{"location":"getting-started/quickstart/#your-first-capture","title":"Your First Capture","text":""},{"location":"getting-started/quickstart/#example-1-print-audio-data","title":"Example 1: Print Audio Data","text":"<pre><code>from proctap import ProcessAudioCapture\n\ndef on_audio(pcm_data: bytes, frame_count: int):\n    \"\"\"Called whenever audio data is available.\"\"\"\n    print(f\"Received {len(pcm_data)} bytes ({frame_count} frames)\")\n\n# Replace 12345 with your target process ID\ntap = ProcessAudioCapture(pid=12345, on_data=on_audio)\ntap.start()\n\ninput(\"Capturing audio... Press Enter to stop.\\n\")\ntap.close()\n</code></pre>"},{"location":"getting-started/quickstart/#example-2-save-to-wav-file","title":"Example 2: Save to WAV File","text":"<pre><code>from proctap import ProcessAudioCapture\nimport wave\nimport numpy as np\n\n# Open WAV file for writing\nwav = wave.open(\"output.wav\", \"wb\")\nwav.setnchannels(2)        # Stereo\nwav.setsampwidth(2)        # 16-bit PCM\nwav.setframerate(48000)    # 48 kHz\n\ndef on_audio(pcm_data: bytes, frame_count: int):\n    \"\"\"Convert float32 to int16 and write to WAV file.\"\"\"\n    # Backend provides float32, convert to int16 for WAV\n    float_samples = np.frombuffer(pcm_data, dtype=np.float32)\n    int16_samples = (np.clip(float_samples, -1.0, 1.0) * 32767).astype(np.int16)\n    wav.writeframes(int16_samples.tobytes())\n\n# Capture audio\nwith ProcessAudioCapture(pid=12345, on_data=on_audio):\n    input(\"Recording... Press Enter to stop.\\n\")\n\nwav.close()\nprint(\"Saved to output.wav\")\n</code></pre>"},{"location":"getting-started/quickstart/#example-3-async-iterator-pattern","title":"Example 3: Async Iterator Pattern","text":"<pre><code>import asyncio\nfrom proctap import ProcessAudioCapture\n\nasync def capture_audio():\n    tap = ProcessAudioCapture(pid=12345)\n    tap.start()\n\n    # Process audio chunks asynchronously\n    async for chunk in tap.iter_chunks():\n        print(f\"Got {len(chunk)} bytes\")\n        # Process the audio data...\n\n        # Example: stop after 100 chunks\n        if count &gt;= 100:\n            break\n\n    tap.close()\n\n# Run the async function\nasyncio.run(capture_audio())\n</code></pre>"},{"location":"getting-started/quickstart/#audio-format","title":"Audio Format","text":"<p>ProcTap always provides audio in this format:</p> Parameter Value Sample Rate 44,100 Hz (CD quality) Channels 2 (stereo) Bit Depth 16-bit Format PCM (linear) <p>Fixed Format</p> <p>The audio format is hardcoded in the C++ backend and cannot be changed without recompiling. The <code>StreamConfig</code> class exists for API compatibility but does not affect the actual format.</p>"},{"location":"getting-started/quickstart/#context-manager-pattern","title":"Context Manager Pattern","text":"<p>ProcTap supports Python's <code>with</code> statement for automatic cleanup:</p> <pre><code>from proctap import ProcessAudioCapture\n\ndef on_audio(data: bytes, frames: int):\n    print(f\"Audio: {len(data)} bytes\")\n\n# Automatically calls close() when exiting\nwith ProcessAudioCapture(pid=12345, on_data=on_audio):\n    input(\"Press Enter to stop...\\n\")\n# tap.close() is called automatically\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Always handle potential errors when working with process audio:</p> <pre><code>from proctap import ProcessAudioCapture\n\ntry:\n    tap = ProcessAudioCapture(pid=12345)\n    tap.start()\n\n    input(\"Capturing... Press Enter to stop.\\n\")\n\nexcept ProcessLookupError:\n    print(\"Error: Process not found or already terminated\")\nexcept PermissionError:\n    print(\"Error: No permission to access process audio\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\nfinally:\n    tap.close()\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that finds a process by name and records to WAV:</p> <pre><code>from proctap import ProcessAudioCapture\nimport wave\nimport psutil\nimport sys\n\ndef find_pid(name: str) -&gt; int:\n    \"\"\"Find PID by process name.\"\"\"\n    for proc in psutil.process_iter(['pid', 'name']):\n        if name.lower() in proc.info['name'].lower():\n            return proc.info['pid']\n    raise ValueError(f\"Process '{name}' not found\")\n\ndef main():\n    # Find VRChat process\n    try:\n        pid = find_pid(\"VRChat\")\n        print(f\"Found VRChat with PID: {pid}\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n\n    # Setup WAV file\n    wav = wave.open(\"vrchat_audio.wav\", \"wb\")\n    wav.setnchannels(2)\n    wav.setsampwidth(2)\n    wav.setframerate(44100)\n\n    # Capture callback\n    def on_audio(data: bytes, frames: int):\n        wav.writeframes(data)\n\n    # Start capture\n    try:\n        with ProcessAudioCapture(pid=pid, on_data=on_audio):\n            print(\"Recording VRChat audio...\")\n            print(\"Press Enter to stop.\")\n            input()\n    except KeyboardInterrupt:\n        print(\"\\nStopped by user\")\n    finally:\n        wav.close()\n        print(\"Saved to vrchat_audio.wav\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>GitHub Examples - More code examples</li> </ul>"}]}